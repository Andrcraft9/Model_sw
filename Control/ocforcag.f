C======================================================================
C(C) DIANSKY N.A. (dinar@inm.ras.ru), GUSEV A.V. 31.01.2006
C MODULE CONTAINS PROCEDURES NEEDED FOR OCEAN FORCING DEFINITION
C                 FOR DATA SPECIFIED ON ATMOSPHERIC GRID
C                 AND INTERFACE POCEDURES FOR COUPLING ATMOSPHERIC
C                 AND OCEAN GCMs
C======================================================================
      SUBROUTINE BUILD_INTRP_MTRX(PATH2FLUX,ATMASK)
      IMPLICIT NONE
      CHARACTER*(*) PATH2FLUX,ATMASK
      INCLUDE '0COM.INC'
      INCLUDE '1ATMFORCING.INC'
	INCLUDE '0A2OINTRP.INC'
      INCLUDE '1LREC.INC'       !SET LONG OF UNIQUE RECL
      INCLUDE '1BASTYPE.INC'
	INCLUDE '1STDOUT.INC'
	INCLUDE '2STDOUT.INC'
      CHARACTER(2048) FILENAME

	CHARACTER COMMENT*80

      INTEGER,ALLOCATABLE:: ATM_MASK(:,:) !SEA-LAND MASK FOR ATM GRID
      REAL  XA(NXA),          !ATM LON-GRID
     &      YA(NYA)           !ATM LAT-GRID

      CHARACTER FRMT*16,FRMT1*16
      INTEGER I,J,M,N,IERR
      INTEGER LU_INT(NX,NY),LU_INT_NSKIP(NX,NY)

      ALLOCATE(ATM_MASK(NXA,NYA))

	INCLUDE '1ATMGRID.INC'

      WRITE(FRMT,1000) MMA-MMMA+1
1000  FORMAT('(',I9,'I1)')

      WRITE(FRMT1,1001) NX_GEO
1001  FORMAT('(',I9,'I1)')

C     INITIALIZATION OF ATMOSPHERIC SEA-LAND MASK      
      IF(ATMASK.EQ.'none'.OR.ATMASK.EQ.'NONE') THEN

            ATM_MASK=0

      ELSE
	      ATM_MASK=1

C FULL FILE NAME OF ATMOSPHERIC MASK ON ATMOSPHERIC GRID
            CALL FULFNAME(FILENAME,PATH2FLUX,ATMASK,IERR)

            OPEN (11,FILE=FILENAME,STATUS='OLD',RECL=(MMA-MMMA+1)*LRECL)

	      WRITE(*,'(A,A)') ' READ FILE WITH ATMOSPHERIC MASK: ',
     &             FILENAME(1:LEN_TRIM(FILENAME))
      
            DO N=NNA,NNNA,-1
               READ(11,FRMT,END=99) (ATM_MASK(M,N),M=MMMA,MMA)
            ENDDO

	CLOSE(11)

      END IF
      
	WRITE(*,*) 'BUILDING MATRIX FOR INTERPOLATION FROM ATM TO OCEAN'
C  CALCULATING INTERPOLATION MATRIX ELEMENTS   
	IF(CURVE_GRID.EQ.0) THEN
C      IN CASE OF SPHERICAL SYSTEM (POSSIBLE ROTATED)
       CALL WEIGHT_MATRIX_INTRP_VEC(
     &     XA,            !ARRAY OF X-GRID VALUES (INPUT) 
     &     YA,            !ARRAY OF Y-GRID VALUES (INPUT)
     &    NXA,            !NUMBER OF X-GRID POINTS(INPUT)
     &    NYA,            !NUMBER OF Y-GRID POINTS(INPUT)
     &    XT,             !ARRAY OF X-GRID VALUES (OUTPUT)
     &    YT,             !ARRAY OF Y-GRID VALUES (OUTPUT)
     &    NX,             !NUMBER OF X-GRID POINTS(OUTPUT)
     &    NY,             !NUMBER OF Y-GRID POINTS(OUTPUT)
     &   ATM_MASK,        !INPUT SEA-LAND MASK
     &    LU,             !OUTPUT SEA-LAND MASK
     & I_INPUT_A2O,       !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & J_INPUT_A2O,       !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & WGHT_MTRX_A2O,     !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     & ROTVEC_COEFF_A2O,  !COS AND SIN OF ANGLES BETWEEN PARALLELS
     & ROTATION_ON_LON,   !ANGLE OF ROTATION ON LONGITUDE
     & ROTATION_ON_LAT,   !ANGLE OF ROTATION ON LATITUDE
     &   1,               !INDEX OF PERIODICITY:=0 -NONPERIODIC,=1 -PERIODIC CASE
     &   1,               !FILLING MISSED VALUES (0-NO, 1-YES)
     &         MMMA,      !FIRST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &          MMA,      ! LAST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &         NNNA,      !FIRST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &          NNA,      ! LAST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &          MMM,      !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &           MM,      ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &          NNN,      !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &           NN)      ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
      
      END IF
   
	IF(CURVE_GRID.EQ.1) THEN
C      IN CASE OF SPECIAL SYSTEM WHITH DISPLACED NORTH POLE
       CALL WEIGHT_MATRIX_INTRP_VEC_SPECIAL(
     &     XA,            !ARRAY OF X-GRID VALUES (INPUT) 
     &     YA,            !ARRAY OF Y-GRID VALUES (INPUT)
     &    NXA,            !NUMBER OF X-GRID POINTS(INPUT)
     &    NYA,            !NUMBER OF Y-GRID POINTS(INPUT)
     &    XT,             !ARRAY OF X-GRID VALUES (OUTPUT)
     &    YT,             !ARRAY OF Y-GRID VALUES (OUTPUT)
     &   NX,              !NUMBER OF X-GRID POINTS(OUTPUT)
     &   NY,              !NUMBER OF Y-GRID POINTS(OUTPUT)
     &   ATM_MASK,        !INPUT SEA-LAND MASK
     &   LU,              !OUTPUT SEA-LAND MASK
     & I_INPUT_A2O,       !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & J_INPUT_A2O,       !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & WGHT_MTRX_A2O,     !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     & ROTVEC_COEFF_A2O,  !COS AND SIN OF ANGLES BETWEEN PARALLELS
     &   X_POLE,           !LON OF REAL NORTH POLE IN SPEC. SYSTEM
     &   Y_POLE,           !LAT OF REAL NORTH POLE IN SPEC. SYSTEM
     &   P_POLE,           !LON OF NEW NORT POLE IN GEO SYSTEM
     &   Q_POLE,           !LAT OF NEW NORT POLE IN GEO SYSTEM
     &        1,           !INDEX OF PERIODICITY:=0 -NONPERIODIC,=1 -PERIODIC CASE
     &        1,           !FILLING MISSED VALUES (0-NO, 1-YES)
     &         MMMA,       !FIRST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &          MMA,       ! LAST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &         NNNA,       !FIRST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &          NNA,       ! LAST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &         MMM,        !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &          MM,        ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &         NNN,        !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &          NN)        ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)

      END IF

	IF(CURVE_GRID.EQ.2) THEN
C      IN CASE OF SPECIAL SYSTEM WITH BOTH DISPLACED POLES
       CALL WEIGHT_MATRIX_INTRP_VEC_SPECIAL_2(
     &     XA,            !ARRAY OF X-GRID VALUES (INPUT) 
     &     YA,            !ARRAY OF Y-GRID VALUES (INPUT)
     &    NXA,            !NUMBER OF X-GRID POINTS(INPUT)
     &    NYA,            !NUMBER OF Y-GRID POINTS(INPUT)
     &    XT,             !ARRAY OF X-GRID VALUES (OUTPUT)
     &    YT,             !ARRAY OF Y-GRID VALUES (OUTPUT)
     &   NX,              !NUMBER OF X-GRID POINTS(OUTPUT)
     &   NY,              !NUMBER OF Y-GRID POINTS(OUTPUT)
     &   ATM_MASK,        !INPUT SEA-LAND MASK
     &   LU,              !OUTPUT SEA-LAND MASK
     & I_INPUT_A2O,       !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & J_INPUT_A2O,       !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & WGHT_MTRX_A2O,     !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     & ROTVEC_COEFF_A2O,  !COS AND SIN OF ANGLES BETWEEN PARALLELS
     &   X_POLE,           !LON OF REAL NORTH POLE IN SPEC. SYSTEM
     &   Y_POLE,           !LAT OF REAL NORTH POLE IN SPEC. SYSTEM
     &   P_POLE,           !LON OF NEW NORT POLE IN GEO SYSTEM
     &        1,           !INDEX OF PERIODICITY:=0 -NONPERIODIC,=1 -PERIODIC CASE
     &        1,           !FILLING MISSED VALUES (0-NO, 1-YES)
     &         MMMA,       !FIRST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &          MMA,       ! LAST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &         NNNA,       !FIRST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &          NNA,       ! LAST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &         MMM,        !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &          MM,        ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &         NNN,        !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &          NN)        ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)

      END IF
      

      DEALLOCATE(ATM_MASK)



C IF STANDART GEO OUTPUT IS SET
      IF(GEO_OUTPUT.GT.0) THEN
      
	 LU_INT=NINT(1.0-LU)
	 LU_INT_NSKIP=0

	 WRITE(*,*) 'BUILDING MATRIX FOR INTERPOLATION FROM MODEL TO GEO'
        
        OPEN (12,FILE=OUT_MASK_FILE,STATUS='OLD',RECL=NX_GEO*LRECL)

C READING MASK FOR OUTPUT GRID
	      WRITE(*,'(A,A)') ' READ FILE WITH OUTPUT OCEAN MASK: ',
     &             OUT_MASK_FILE(1:LEN_TRIM(OUT_MASK_FILE))
            READ (12,  '(A)') COMMENT(1:MIN(80,NX_GEO))  
            WRITE(*,'(1X,A)') COMMENT    
            
            DO N=NY_GEO,1,-1
               READ(12,FRMT1,END=100) (IMASK_OUT(M,N),M=1,NX_GEO)
            ENDDO
C  CALCULATING INTERPOLATION MATRIX ELEMENTS FOR BACK INTERPOLATION 	  
        
C CONVERSION INTEGER DIOGIN MASK TO REAL MODEL MASK
           CALL IDM2RMM(RMASK_OUT,IMASK_OUT,NX_GEO,NY_GEO)        
           RMASK_NSKIP=1.0

            IF (NBAS_GEO.GT.1) THEN
            READ (12,  '(A)') COMMENT(1:MIN(80,NX_GEO))
            WRITE(*,'(1X,A)') COMMENT

C READING BASIN CODES FOR OUTPUT GRID            
            DO N=NY_GEO,1,-1
               READ(12,FRMT1,END=100) (IMASK_OUT(M,N),M=1,NX_GEO)
            ENDDO
            
            END IF        
               
        CLOSE(12)	
      
        DO M=1,NX_GEO
         XT_G(M)=X0_OUT+(M-MMM_G)*DX_OUT    
        END DO      

        DO N=1,NY_GEO
         YT_G(N)=Y0_OUT+(N-NNN_G)*DY_OUT    
        END DO 
        
        DO N=2,NY_GEO-1     
        DO M=2,NX_GEO-1
        DX_G(M,N)=(XT_G(M+1)-XT_G(M-1))/2.0*3.1415926/180.0
     &            *COS(3.1415926*YT_G(N)/180.0)
        DY_G(M,N)=(YT_G(N+1)-YT_G(N-1))/2.0*3.1415926/180.0
        END DO 
        END DO                 

	IF(CURVE_GRID.EQ.0) THEN
C      IN CASE OF SPHERICAL SYSTEM (POSSIBLE ROTATED)
       CALL WEIGHT_MATRIX_INTRP_VEC(
     &     XT,            !ARRAY OF X-GRID VALUES (INPUT) 
     &     YT,            !ARRAY OF Y-GRID VALUES (INPUT)
     &    NX,             !NUMBER OF X-GRID POINTS(INPUT)
     &    NY,             !NUMBER OF Y-GRID POINTS(INPUT)
     &    XT_G-ROTATION_ON_LON, !ARRAY OF X-GRID VALUES (OUTPUT)
     &    YT_G,           !ARRAY OF Y-GRID VALUES (OUTPUT)
     &    NX_GEO,         !NUMBER OF X-GRID POINTS(OUTPUT)
     &    NY_GEO,         !NUMBER OF Y-GRID POINTS(OUTPUT)
     &   LU_INT,          !INPUT SEA-LAND MASK
     &   RMASK_NSKIP,     !OUTPUT SEA-LAND MASK
     & I_INPUT_M2G,       !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & J_INPUT_M2G,       !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & WGHT_MTRX_M2G,     !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     & ROTVEC_COEFF_M2G,  !COS AND SIN OF ANGLES BETWEEN PARALLELS
     &             0.0,   !ANGLE OF ROTATION ON LONGITUDE
     & -ROTATION_ON_LAT,  !ANGLE OF ROTATION ON LATITUDE
     &   1,               !INDEX OF PERIODICITY:=0 -NONPERIODIC,=1 -PERIODIC CASE
     &   1,               !FILLING MISSED VALUES (0-NO, 1-YES)
     &         MMM,       !FIRST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &          MM,       ! LAST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &         NNN,       !FIRST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &          NN,       ! LAST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &          MMM_G,    !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &           MM_G,    ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &          NNN_G,    !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &           NN_G)    ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
      
       CALL WEIGHT_MATRIX_INTRP_VEC(
     &     XT,            !ARRAY OF X-GRID VALUES (INPUT) 
     &     YT,            !ARRAY OF Y-GRID VALUES (INPUT)
     &    NX,             !NUMBER OF X-GRID POINTS(INPUT)
     &    NY,             !NUMBER OF Y-GRID POINTS(INPUT)
     &    XT_G-ROTATION_ON_LON, !ARRAY OF X-GRID VALUES (OUTPUT)
     &    YT_G,           !ARRAY OF Y-GRID VALUES (OUTPUT)
     &    NX_GEO,         !NUMBER OF X-GRID POINTS(OUTPUT)
     &    NY_GEO,         !NUMBER OF Y-GRID POINTS(OUTPUT)
     &   LU_INT_NSKIP,    !INPUT SEA-LAND MASK
     &   RMASK_NSKIP,     !OUTPUT SEA-LAND MASK
     & I_INPUT_M2G_NSKIP,       !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & J_INPUT_M2G_NSKIP,       !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & WGHT_MTRX_M2G_NSKIP,     !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     & ROTVEC_COEFF_M2G,  !COS AND SIN OF ANGLES BETWEEN PARALLELS
     &             0.0,   !ANGLE OF ROTATION ON LONGITUDE
     & -ROTATION_ON_LAT,  !ANGLE OF ROTATION ON LATITUDE
     &   1,               !INDEX OF PERIODICITY:=0 -NONPERIODIC,=1 -PERIODIC CASE
     &   1,               !FILLING MISSED VALUES (0-NO, 1-YES)
     &         MMM,       !FIRST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &          MM,       ! LAST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &         NNN,       !FIRST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &          NN,       ! LAST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &          MMM_G,    !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &           MM_G,    ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &          NNN_G,    !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &           NN_G)    ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
      
      END IF  

	IF(CURVE_GRID.EQ.1) THEN
C      IN CASE OF SPECIAL SYSTEM WHITH DISPLACED NORTH POLE
       CALL WEIGHT_MATRIX_INTRP_VEC_SPECIAL(
     &     XT,            !ARRAY OF X-GRID VALUES (INPUT) 
     &     YT,            !ARRAY OF Y-GRID VALUES (INPUT)
     &     NX,            !NUMBER OF X-GRID POINTS(INPUT)
     &     NY,            !NUMBER OF Y-GRID POINTS(INPUT)
     &     XT_G,          !ARRAY OF X-GRID VALUES (OUTPUT)
     &     YT_G,          !ARRAY OF Y-GRID VALUES (OUTPUT)
     &     NX_GEO,        !NUMBER OF X-GRID POINTS(OUTPUT)
     &     NY_GEO,        !NUMBER OF Y-GRID POINTS(OUTPUT)
     &     LU_INT,        !INPUT SEA-LAND MASK
     &   RMASK_NSKIP,     !OUTPUT SEA-LAND MASK
     & I_INPUT_M2G,       !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & J_INPUT_M2G,       !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & WGHT_MTRX_M2G,     !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     & ROTVEC_COEFF_M2G,  !COS AND SIN OF ANGLES BETWEEN PARALLELS
     &   P_POLE,           !LON OF REAL NORTH POLE IN SPEC. SYSTEM
     &   Q_POLE,           !LAT OF REAL NORTH POLE IN SPEC. SYSTEM
     &   X_POLE,           !LON OF NEW NORT POLE IN GEO SYSTEM
     &   Y_POLE,           !LAT OF NEW NORT POLE IN GEO SYSTEM
     &        1,           !INDEX OF PERIODICITY:=0 -NONPERIODIC,=1 -PERIODIC CASE
     &        1,           !FILLING MISSED VALUES (0-NO, 1-YES)
     &         MMM,        !FIRST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &          MM,        ! LAST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &         NNN,        !FIRST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &          NN,        ! LAST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &         MMM_G,      !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &          MM_G,      ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &         NNN_G,      !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &          NN_G)      ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)

       CALL WEIGHT_MATRIX_INTRP_VEC_SPECIAL(
     &     XT,            !ARRAY OF X-GRID VALUES (INPUT) 
     &     YT,            !ARRAY OF Y-GRID VALUES (INPUT)
     &     NX,            !NUMBER OF X-GRID POINTS(INPUT)
     &     NY,            !NUMBER OF Y-GRID POINTS(INPUT)
     &     XT_G,          !ARRAY OF X-GRID VALUES (OUTPUT)
     &     YT_G,          !ARRAY OF Y-GRID VALUES (OUTPUT)
     &     NX_GEO,        !NUMBER OF X-GRID POINTS(OUTPUT)
     &     NY_GEO,        !NUMBER OF Y-GRID POINTS(OUTPUT)
     &     LU_INT_NSKIP,        !INPUT SEA-LAND MASK
     &   RMASK_NSKIP,     !OUTPUT SEA-LAND MASK
     & I_INPUT_M2G_NSKIP,       !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & J_INPUT_M2G_NSKIP,       !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & WGHT_MTRX_M2G_NSKIP,     !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     & ROTVEC_COEFF_M2G,  !COS AND SIN OF ANGLES BETWEEN PARALLELS
     &   P_POLE,           !LON OF REAL NORTH POLE IN SPEC. SYSTEM
     &   Q_POLE,           !LAT OF REAL NORTH POLE IN SPEC. SYSTEM
     &   X_POLE,           !LON OF NEW NORT POLE IN GEO SYSTEM
     &   Y_POLE,           !LAT OF NEW NORT POLE IN GEO SYSTEM
     &        1,           !INDEX OF PERIODICITY:=0 -NONPERIODIC,=1 -PERIODIC CASE
     &        1,           !FILLING MISSED VALUES (0-NO, 1-YES)
     &         MMM,        !FIRST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &          MM,        ! LAST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &         NNN,        !FIRST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &          NN,        ! LAST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &         MMM_G,      !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &          MM_G,      ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &         NNN_G,      !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &          NN_G)      ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)

      END IF

	IF(CURVE_GRID.EQ.2) THEN
C      IN CASE OF SPECIAL SYSTEM WITH BOTH DISPLACED POLES
       CALL WEIGHT_MATRIX_INTRP_VEC_SPECIAL_2(
     &     XT,            !ARRAY OF X-GRID VALUES (INPUT) 
     &     YT,            !ARRAY OF Y-GRID VALUES (INPUT)
     &     NX,            !NUMBER OF X-GRID POINTS(INPUT)
     &     NY,            !NUMBER OF Y-GRID POINTS(INPUT)
     &     XT_G,          !ARRAY OF X-GRID VALUES (OUTPUT)
     &     YT_G,          !ARRAY OF Y-GRID VALUES (OUTPUT)
     &     NX_GEO,        !NUMBER OF X-GRID POINTS(OUTPUT)
     &     NY_GEO,        !NUMBER OF Y-GRID POINTS(OUTPUT)
     &     LU_INT,        !INPUT SEA-LAND MASK
     &   RMASK_NSKIP,     !OUTPUT SEA-LAND MASK
     & I_INPUT_M2G,       !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & J_INPUT_M2G,       !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & WGHT_MTRX_M2G,     !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     & ROTVEC_COEFF_M2G,  !COS AND SIN OF ANGLES BETWEEN PARALLELS
     &   P_POLE,           !LON OF REAL NORTH POLE IN SPEC. SYSTEM
     &  180-Y_POLE,        !LAT OF REAL NORTH POLE IN SPEC. SYSTEM
     &   X_POLE,           !LON OF NEW NORT POLE IN GEO SYSTEM
     &        1,           !INDEX OF PERIODICITY:=0 -NONPERIODIC,=1 -PERIODIC CASE
     &        1,           !FILLING MISSED VALUES (0-NO, 1-YES)
     &         MMM,        !FIRST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &          MM,        ! LAST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &         NNN,        !FIRST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &          NN,        ! LAST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &         MMM_G,      !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &          MM_G,      ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &         NNN_G,      !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &          NN_G)      ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)

       CALL WEIGHT_MATRIX_INTRP_VEC_SPECIAL_2(
     &     XT,            !ARRAY OF X-GRID VALUES (INPUT) 
     &     YT,            !ARRAY OF Y-GRID VALUES (INPUT)
     &     NX,            !NUMBER OF X-GRID POINTS(INPUT)
     &     NY,            !NUMBER OF Y-GRID POINTS(INPUT)
     &     XT_G,          !ARRAY OF X-GRID VALUES (OUTPUT)
     &     YT_G,          !ARRAY OF Y-GRID VALUES (OUTPUT)
     &     NX_GEO,        !NUMBER OF X-GRID POINTS(OUTPUT)
     &     NY_GEO,        !NUMBER OF Y-GRID POINTS(OUTPUT)
     &     LU_INT_NSKIP,        !INPUT SEA-LAND MASK
     &   RMASK_NSKIP,     !OUTPUT SEA-LAND MASK
     & I_INPUT_M2G_NSKIP,       !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & J_INPUT_M2G_NSKIP,       !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & WGHT_MTRX_M2G_NSKIP,     !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     & ROTVEC_COEFF_M2G,  !COS AND SIN OF ANGLES BETWEEN PARALLELS
     &   P_POLE,           !LON OF REAL NORTH POLE IN SPEC. SYSTEM
     &  180-Y_POLE,        !LAT OF REAL NORTH POLE IN SPEC. SYSTEM
     &   X_POLE,           !LON OF NEW NORT POLE IN GEO SYSTEM
     &        1,           !INDEX OF PERIODICITY:=0 -NONPERIODIC,=1 -PERIODIC CASE
     &        1,           !FILLING MISSED VALUES (0-NO, 1-YES)
     &         MMM,        !FIRST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &          MM,        ! LAST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &         NNN,        !FIRST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &          NN,        ! LAST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &         MMM_G,      !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &          MM_G,      ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &         NNN_G,      !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &          NN_G)      ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
      END IF
      
      
      END IF

	RETURN

99    WRITE(*,*)' ERROR IN READING FILE ATMMASK.ARR ',
     &            FILENAME(1:LEN_TRIM(FILENAME))
      STOP 1

100   WRITE(*,*)' ERROR IN READING FILE OUTMASK.ARR ',
     &            OUT_MASK_FILE(1:LEN_TRIM(OUT_MASK_FILE))
      STOP 1	

	END


C======================================================================
C ATMOSPHERIC DATA TIME INTERPOLATION ON ATMOSPHERIC GRID

      SUBROUTINE INIATMF(DAYS_IN_4YR,DAY_OF_4YR,MONTH_COUNTER,
     &                   NEWMONTH,PATH2FLUX,SS_FILES,SS_FILES_FULLNAME,
     &                   IGT,IGS,IGWS,IGICE,NDAYS_IN_4YR,M_YEAR_OF_4YR,
     &                   M_YEAR,M_MONTH_OF_4YR,
     &                   M_DAY_OF_MONTH,M_HOUR_OF_DAY,M_TIME_CHANGED)
	IMPLICIT NONE
	
	INCLUDE '0COM.INC'
      INCLUDE '1ATMFORCING.INC'
	INTEGER    NDAYS_IN_4YR(0:48),M_DAY_OF_MONTH,M_YEAR_OF_4YR,
     &           M_HOUR_OF_DAY,M_YEAR,M_MONTH_OF_4YR,
     &        M_TIME_CHANGED(7)  !INDICATOR OF TIME CHANGED (0-NOT,1-CHANGED) FOR
                                 !1-SEC,2-MIN,3-HOUR,4-DAY,5-MONTH,6-YEAR,7-4YRS
C EXTERNAL TIME INTERPOLATION PARAMETERS
      REAL DAYS_IN_4YR(49), !DAY DISTRIBUTION IN 4-YEAR
     &     DAY_OF_4YR       !THE PRESENT DAY OF 4-YEAR PERIODICITY
      INTEGER MONTH_COUNTER,       !THE PRESENT MONTH IN 4-YEAR
     &        NEWMONTH             !COMMAND TO READING DATA(>1-Y,0-NO)
C SETTING FILES WITH DATA PARAMETERS
      CHARACTER*(*) PATH2FLUX,SS_FILES(20),SS_FILES_FULLNAME(20)
C SS_FILES(1) !FILE WITH SST
C SS_FILES(2) !FILE WITH SSS
C SS_FILES(3) !FILE WITH TAUX(OCMOD) OR WNDX(ICEMOD)
C SS_FILES(4) !FILE WITH TAUY(OCMOD) OR WNDY(ICEMOD)
C SS_FILES(5) !FILE WITH HEAT BALANCE(OCMOD) OR DW-LW-RAD(ICEMOD)
C SS_FILES(6) !FILE WITH SW-RAD BALANCE(OCMOD) OR DW-SW-RAD(ICEMOD)
C SS_FILES(7) !FILE WITH PRECIP-EVAP (OCMOD) OR PRECIP(ICEMOD)
C SS_FILES(8) !FILE WITH ICE MASK(OCMOD) OR HUMIDITY(ICEMOD)
C SS_FILES(9) !FILE WITH TEMP OF ATM (ICEMOD)
C SS_FILES(10)!FILE WITH PRESSURE (ICEMOD)
C SS_FILES(11)!FILE WITH RIVER RUNOFF
C SS_FILES(12)!FILE WITH !DW-LW-RAD[W/M**2]
C SS_FILES(13)!FILE WITH !DW-SW-RAD[W/M**2]
C SS_FILES(14)!FILE WITH !PRECIPIT[M/S] 
C SS_FILES(15)!FILE WITH !TEMP OF ATMOSPHER
C SS_FILES(16)!FILE WITH !HUMIDITY [G/KG] 
C SS_FILES(17)!FILE WITH !U-WIND SPEED[M/S]
C SS_FILES(18)!FILE WITH !V-WIND SPEED[M/S]

C+++++++++++++++++SEA SURFACE CONTROL PARAMETERS++++++++++++++++++++++++
      INTEGER IGT,IGS,IGWS,IGICE
C         TYPES OF SS CONDITION FOR T,S:
C   IGT,IGS=
C         1 - FIRST CONDITION
C         (ONLY T,S AT OCEAN SURFACE ARE USED)
C         2 - SECOND CONDITION 
C         (HEAT AND FRESH WATER BALANCES ARE USED)
C         3 - THIRD CONDITION
C         (HEAT AND SALT FLUXES ARE CALCULATED BY BULK-FORMULAE)

C         TYPES OF SS CONDITION FOR U,V:
C   IGWS=
C         1 - WIND STRESS COMPONENTS ARE READ FROM FILES,
C             ATM PRESSURE DOES NOT AFFECT DYNAMICS
C         2 - WIND STRESS COMPONENTS ARE READ FROM FILES,
C             ATM PRESSURE AFFECTS DYNAMICS
C         3 - WIND STRESS COMPONENTS ARE CALCULATED BY BULK FORMULAE,
C             ATM PRESSURE DOES NOT AFFECT DYNAMICS
C         4 - WIND STRESS COMPONENTS ARE CALCULATED BY BULK FORMULAE,
C             ATM PRESSURE AFFECTS DYNAMICS

C         USAGE OF ICE BLOCK IN OCEAN MODEL:
C   IGICE=
C         0 - ICE BLOCK IS NOT USED
C         1 - ICE BLOCK IS     USED

C IAVT=  1-DO NOT REMOVE SPACE AVERAGING HEAT FLUX,
C        2-       REMOVE SPACE AVERAGING HEAT FLUX;
C IAVS=  1-DO NOT REMOVE SPACE AVERAGING WRESH WATER FLUX,
C        2-       REMOVE SPACE AVERAGING WRESH WATER FLUX.
C+++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

      IF(IABS(IGWS).LE.2) THEN
C  FORMING FULL FILE NAME FOR ZONAL WIND STRESS
            CALL ATM_FULL_NAME 
     &            (SS_FILES(3),     ! ORIGINAL FILE NAME
     &    SS_FILES_FULLNAME(3),     ! FULL FILE NAME
     &               PATH2FLUX,     ! PATH TO FLUX DATA
     &                NEWMONTH,     ! SIGNAL TO READ DATA FOR MONTHLY MEAANS
     &            IND_CLIM_TXA,     ! INDEX OF CLIMATICITY (0-CLIMATIC DATA, 1 - REAL YEAR DATA)
     &                  M_YEAR,     ! CURRENT YEAR NUMBER
     &          M_TIME_CHANGED)     ! INDICATOR OF TIME CHANGED(0-NOT,1-CHANGED) 
                                    ! 1-SEC,2-MIN,3-HOUR,4-DAY,5-MONTH,6-YEAR,7-4YRS
C READING AND TIME INTERPOLATION OF ZONAL WIND STRESS
       CALL FORC_TIME_INTERPOLATION(SS_FILES_FULLNAME(3),TXA,
     &       DAYS_IN_4YR,DAY_OF_4YR,MONTH_COUNTER,
     &       NXA,NYA,FTYPE_TXA,NEWMONTH,NDAYS_IN_4YR,M_YEAR_OF_4YR,
     &       M_MONTH_OF_4YR,NTIME_TXA,TIME_RESOLUTION_TXA, 
     &       M_DAY_OF_MONTH,M_HOUR_OF_DAY,M_TIME_CHANGED)
      

C  FORMING FULL FILE NAME FOR MERIDIONAL WIND STRESS
            CALL ATM_FULL_NAME 
     &            (SS_FILES(4),     ! ORIGINAL FILE NAME
     &    SS_FILES_FULLNAME(4),     ! FULL FILE NAME
     &               PATH2FLUX,     ! PATH TO FLUX DATA
     &                NEWMONTH,     ! SIGNAL TO READ DATA FOR MONTHLY MEAANS
     &            IND_CLIM_TYA,     ! INDEX OF CLIMATICITY (0-CLIMATIC DATA, 1 - REAL YEAR DATA)
     &                  M_YEAR,     ! CURRENT YEAR NUMBER
     &          M_TIME_CHANGED)     ! INDICATOR OF TIME CHANGED(0-NOT,1-CHANGED) 
                                    ! 1-SEC,2-MIN,3-HOUR,4-DAY,5-MONTH,6-YEAR,7-4YRS
C READING AND TIME INTERPOLATION OF MERIDIONAL WIND STRESS
       CALL FORC_TIME_INTERPOLATION(SS_FILES_FULLNAME(4),TYA,
     &       DAYS_IN_4YR,DAY_OF_4YR,MONTH_COUNTER,
     &       NXA,NYA,FTYPE_TYA,NEWMONTH,NDAYS_IN_4YR,M_YEAR_OF_4YR,
     &       M_MONTH_OF_4YR,NTIME_TYA,TIME_RESOLUTION_TYA, 
     &       M_DAY_OF_MONTH,M_HOUR_OF_DAY,M_TIME_CHANGED)
	END IF

C=============================================================================
      
      IF(IGT.EQ.2) THEN
C  FORMING FULL FILE NAME FOR HEAT BALANCE 
            CALL ATM_FULL_NAME 
     &            (SS_FILES(5),     ! ORIGINAL FILE NAME
     &    SS_FILES_FULLNAME(5),     ! FULL FILE NAME
     &               PATH2FLUX,     ! PATH TO FLUX DATA
     &                NEWMONTH,     ! SIGNAL TO READ DATA FOR MONTHLY MEAANS
     &            IND_CLIM_QBL,     ! INDEX OF CLIMATICITY (0-CLIMATIC DATA, 1 - REAL YEAR DATA)
     &                  M_YEAR,     ! CURRENT YEAR NUMBER
     &          M_TIME_CHANGED)     ! INDICATOR OF TIME CHANGED(0-NOT,1-CHANGED) 
                                    ! 1-SEC,2-MIN,3-HOUR,4-DAY,5-MONTH,6-YEAR,7-4YRS
C READING AND TIME INTERPOLATION OF HEAT BALANCE
       CALL FORC_TIME_INTERPOLATION(SS_FILES_FULLNAME(5),QBL,
     &       DAYS_IN_4YR,DAY_OF_4YR,MONTH_COUNTER,
     &       NXA,NYA,FTYPE_QBL,NEWMONTH,NDAYS_IN_4YR,M_YEAR_OF_4YR,
     &       M_MONTH_OF_4YR,NTIME_QBL,TIME_RESOLUTION_QBL, 
     &       M_DAY_OF_MONTH,M_HOUR_OF_DAY,M_TIME_CHANGED)

C============================================================================

C  FORMING FULL FILE NAME FOR  BALANCE 
            CALL ATM_FULL_NAME 
     &            (SS_FILES(6),     ! ORIGINAL FILE NAME
     &    SS_FILES_FULLNAME(6),     ! FULL FILE NAME
     &               PATH2FLUX,     ! PATH TO FLUX DATA
     &                NEWMONTH,     ! SIGNAL TO READ DATA FOR MONTHLY MEAANS
     &            IND_CLIM_QSW,     ! INDEX OF CLIMATICITY (0-CLIMATIC DATA, 1 - REAL YEAR DATA)
     &                  M_YEAR,     ! CURRENT YEAR NUMBER
     &          M_TIME_CHANGED)     ! INDICATOR OF TIME CHANGED(0-NOT,1-CHANGED) 
                                    ! 1-SEC,2-MIN,3-HOUR,4-DAY,5-MONTH,6-YEAR,7-4YRS
C READING AND TIME INTERPOLATION OF SW-RADIATION BALANCE
       CALL FORC_TIME_INTERPOLATION(SS_FILES_FULLNAME(6),QSW,
     &       DAYS_IN_4YR,DAY_OF_4YR,MONTH_COUNTER,
     &       NXA,NYA,FTYPE_QSW,NEWMONTH,NDAYS_IN_4YR,M_YEAR_OF_4YR,
     &       M_MONTH_OF_4YR,NTIME_QSW,TIME_RESOLUTION_QSW, 
     &       M_DAY_OF_MONTH,M_HOUR_OF_DAY,M_TIME_CHANGED)
	
      END IF

C=============================================================================

      IF(IGS.EQ.2) THEN
C  FORMING FULL FILE NAME FOR FRESH WATER BALANCE 
            CALL ATM_FULL_NAME 
     &            (SS_FILES(7),     ! ORIGINAL FILE NAME
     &    SS_FILES_FULLNAME(7),     ! FULL FILE NAME
     &               PATH2FLUX,     ! PATH TO FLUX DATA
     &                NEWMONTH,     ! SIGNAL TO READ DATA FOR MONTHLY MEAANS
     &            IND_CLIM_PME,     ! INDEX OF CLIMATICITY (0-CLIMATIC DATA, 1 - REAL YEAR DATA)
     &                  M_YEAR,     ! CURRENT YEAR NUMBER
     &          M_TIME_CHANGED)     ! INDICATOR OF TIME CHANGED(0-NOT,1-CHANGED) 
                                    ! 1-SEC,2-MIN,3-HOUR,4-DAY,5-MONTH,6-YEAR,7-4YRS
C READING AND TIME INTERPOLATION OF FRESH WATER BALANCE
       CALL FORC_TIME_INTERPOLATION(SS_FILES_FULLNAME(7),PME,
     &       DAYS_IN_4YR,DAY_OF_4YR,MONTH_COUNTER,
     &       NXA,NYA,FTYPE_PME,NEWMONTH,NDAYS_IN_4YR,M_YEAR_OF_4YR,
     &       M_MONTH_OF_4YR,NTIME_PME,TIME_RESOLUTION_PME, 
     &       M_DAY_OF_MONTH,M_HOUR_OF_DAY,M_TIME_CHANGED)
	END IF
C================================================================================
      
      IF((IGS.GE.2.OR.IGT.GE.2).AND.IGICE.EQ.0) THEN
C  FORMING FULL FILE NAME FOR ICE MASK 
            CALL ATM_FULL_NAME 
     &            (SS_FILES(8),     ! ORIGINAL FILE NAME
     &    SS_FILES_FULLNAME(8),     ! FULL FILE NAME
     &               PATH2FLUX,     ! PATH TO FLUX DATA
     &                NEWMONTH,     ! SIGNAL TO READ DATA FOR MONTHLY MEAANS
     &            IND_CLIM_SIC,     ! INDEX OF CLIMATICITY (0-CLIMATIC DATA, 1 - REAL YEAR DATA)
     &                  M_YEAR,     ! CURRENT YEAR NUMBER
     &          M_TIME_CHANGED)     ! INDICATOR OF TIME CHANGED(0-NOT,1-CHANGED) 
                                    ! 1-SEC,2-MIN,3-HOUR,4-DAY,5-MONTH,6-YEAR,7-4YRS
C READING AND TIME INTERPOLATION OF ICE MASK
       CALL FORC_TIME_INTERPOLATION(SS_FILES_FULLNAME(8),SIC,
     &       DAYS_IN_4YR,DAY_OF_4YR,MONTH_COUNTER,
     &       NXA,NYA,FTYPE_SIC,NEWMONTH,NDAYS_IN_4YR,M_YEAR_OF_4YR,
     &       M_MONTH_OF_4YR,NTIME_SIC,TIME_RESOLUTION_SIC, 
     &       M_DAY_OF_MONTH,M_HOUR_OF_DAY,M_TIME_CHANGED)     
      END IF
C================================================================================
      
      IF(IGT.EQ.5) THEN
C  FORMING FULL FILE NAME FOR SST (COUPLED MODEL ONLY) 
            CALL ATM_FULL_NAME 
     &            (SS_FILES(9),     ! ORIGINAL FILE NAME
     &    SS_FILES_FULLNAME(9),     ! FULL FILE NAME
     &               PATH2FLUX,     ! PATH TO FLUX DATA
     &                NEWMONTH,     ! SIGNAL TO READ DATA FOR MONTHLY MEAANS
     &            IND_CLIM_TSA,     ! INDEX OF CLIMATICITY (0-CLIMATIC DATA, 1 - REAL YEAR DATA)
     &                  M_YEAR,     ! CURRENT YEAR NUMBER
     &          M_TIME_CHANGED)     ! INDICATOR OF TIME CHANGED(0-NOT,1-CHANGED) 
                                    ! 1-SEC,2-MIN,3-HOUR,4-DAY,5-MONTH,6-YEAR,7-4YRS
C READING AND TIME INTERPOLATION OF SST (COUPLED MODEL ONLY) 
       CALL FORC_TIME_INTERPOLATION(SS_FILES_FULLNAME(9),TSA,
     &       DAYS_IN_4YR,DAY_OF_4YR,MONTH_COUNTER,
     &       NXA,NYA,FTYPE_TSA,NEWMONTH,NDAYS_IN_4YR,M_YEAR_OF_4YR,
     &       M_MONTH_OF_4YR,NTIME_TSA,TIME_RESOLUTION_TSA, 
     &       M_DAY_OF_MONTH,M_HOUR_OF_DAY,M_TIME_CHANGED) 
	END IF
C=================================================================================
      
      IF(IGT.GT.2.OR.IGS.GT.2.OR.IGICE.GT.0.
     &           OR. IABS(IGWS).EQ.2.OR. IABS(IGWS).EQ.4) THEN
C  FORMING FULL FILE NAME FOR SEA LEVEL PRESSURE 
            CALL ATM_FULL_NAME 
     &            (SS_FILES(10),     ! ORIGINAL FILE NAME
     &    SS_FILES_FULLNAME(10),     ! FULL FILE NAME
     &               PATH2FLUX,     ! PATH TO FLUX DATA
     &                NEWMONTH,     ! SIGNAL TO READ DATA FOR MONTHLY MEAANS
     &            IND_CLIM_SLP,     ! INDEX OF CLIMATICITY (0-CLIMATIC DATA, 1 - REAL YEAR DATA)
     &                  M_YEAR,     ! CURRENT YEAR NUMBER
     &          M_TIME_CHANGED)     ! INDICATOR OF TIME CHANGED(0-NOT,1-CHANGED) 
                                    ! 1-SEC,2-MIN,3-HOUR,4-DAY,5-MONTH,6-YEAR,7-4YRS
C READING AND TIME INTERPOLATION OF SEA LEVEL PRESSURE  
       CALL FORC_TIME_INTERPOLATION(SS_FILES_FULLNAME(10),SLP,
     &       DAYS_IN_4YR,DAY_OF_4YR,MONTH_COUNTER,
     &       NXA,NYA,FTYPE_SLP,NEWMONTH,NDAYS_IN_4YR,M_YEAR_OF_4YR,
     &       M_MONTH_OF_4YR,NTIME_SLP,TIME_RESOLUTION_SLP, 
     &       M_DAY_OF_MONTH,M_HOUR_OF_DAY,M_TIME_CHANGED)       
      END IF
C================================================================================

      IF(IGS.GE.2.OR.IGICE.GT.0) THEN
C  FORMING FULL FILE NAME FOR RIVER RUNOFF
            CALL ATM_FULL_NAME 
     &            (SS_FILES(11),     ! ORIGINAL FILE NAME
     &    SS_FILES_FULLNAME(11),     ! FULL FILE NAME
     &               PATH2FLUX,     ! PATH TO FLUX DATA
     &                NEWMONTH,     ! SIGNAL TO READ DATA FOR MONTHLY MEAANS
     &            IND_CLIM_ROFF,     ! INDEX OF CLIMATICITY (0-CLIMATIC DATA, 1 - REAL YEAR DATA)
     &                  M_YEAR,     ! CURRENT YEAR NUMBER
     &          M_TIME_CHANGED)     ! INDICATOR OF TIME CHANGED(0-NOT,1-CHANGED) 
                                    ! 1-SEC,2-MIN,3-HOUR,4-DAY,5-MONTH,6-YEAR,7-4YRS
C READING AND TIME INTERPOLATION OF RIVER RUNOFF  
       CALL FORC_TIME_INTERPOLATION(SS_FILES_FULLNAME(11),ROFF,
     &       DAYS_IN_4YR,DAY_OF_4YR,MONTH_COUNTER,
     &       NXA,NYA,FTYPE_ROFF,NEWMONTH,NDAYS_IN_4YR,M_YEAR_OF_4YR,
     &       M_MONTH_OF_4YR,NTIME_ROFF,TIME_RESOLUTION_ROFF, 
     &       M_DAY_OF_MONTH,M_HOUR_OF_DAY,M_TIME_CHANGED)
	END IF
C================================================================================      

      IF(IGT.GT.2.OR.IGICE.GT.0) THEN
C  FORMING FULL FILE NAME FOR DOWNWARD LW-RADIATION
            CALL ATM_FULL_NAME 
     &            (SS_FILES(12),     ! ORIGINAL FILE NAME
     &    SS_FILES_FULLNAME(12),     ! FULL FILE NAME
     &               PATH2FLUX,     ! PATH TO FLUX DATA
     &                NEWMONTH,     ! SIGNAL TO READ DATA FOR MONTHLY MEAANS
     &            IND_CLIM_LWAT,     ! INDEX OF CLIMATICITY (0-CLIMATIC DATA, 1 - REAL YEAR DATA)
     &                  M_YEAR,     ! CURRENT YEAR NUMBER
     &          M_TIME_CHANGED)     ! INDICATOR OF TIME CHANGED(0-NOT,1-CHANGED) 
                                    ! 1-SEC,2-MIN,3-HOUR,4-DAY,5-MONTH,6-YEAR,7-4YRS
C READING AND TIME INTERPOLATION OF DOWNWARD LW-RADIATION  
       CALL FORC_TIME_INTERPOLATION(SS_FILES_FULLNAME(12),LWAT,
     &       DAYS_IN_4YR,DAY_OF_4YR,MONTH_COUNTER,
     &       NXA,NYA,FTYPE_LWAT,NEWMONTH,NDAYS_IN_4YR,M_YEAR_OF_4YR,
     &       M_MONTH_OF_4YR,NTIME_LWAT,TIME_RESOLUTION_LWAT, 
     &       M_DAY_OF_MONTH,M_HOUR_OF_DAY,M_TIME_CHANGED)
     
C=================================================================================
     	
C  FORMING FULL FILE NAME FOR DOWNWARD SW-RADIATION
            CALL ATM_FULL_NAME 
     &            (SS_FILES(13),     ! ORIGINAL FILE NAME
     &    SS_FILES_FULLNAME(13),     ! FULL FILE NAME
     &               PATH2FLUX,     ! PATH TO FLUX DATA
     &                NEWMONTH,     ! SIGNAL TO READ DATA FOR MONTHLY MEAANS
     &            IND_CLIM_SWAT,     ! INDEX OF CLIMATICITY (0-CLIMATIC DATA, 1 - REAL YEAR DATA)
     &                  M_YEAR,     ! CURRENT YEAR NUMBER
     &          M_TIME_CHANGED)     ! INDICATOR OF TIME CHANGED(0-NOT,1-CHANGED) 
                                    ! 1-SEC,2-MIN,3-HOUR,4-DAY,5-MONTH,6-YEAR,7-4YRS
C READING AND TIME INTERPOLATION OF DOWNWARD SW-RADIATION  
       CALL FORC_TIME_INTERPOLATION(SS_FILES_FULLNAME(13),SWAT,
     &       DAYS_IN_4YR,DAY_OF_4YR,MONTH_COUNTER,
     &       NXA,NYA,FTYPE_SWAT,NEWMONTH,NDAYS_IN_4YR,M_YEAR_OF_4YR,
     &       M_MONTH_OF_4YR,NTIME_SWAT,TIME_RESOLUTION_SWAT, 
     &       M_DAY_OF_MONTH,M_HOUR_OF_DAY,M_TIME_CHANGED) 
C===================================================================================     
           
C  FORMING FULL FILE NAME FOR AIR TEMPERATURE
            CALL ATM_FULL_NAME 
     &            (SS_FILES(15),     ! ORIGINAL FILE NAME
     &    SS_FILES_FULLNAME(15),     ! FULL FILE NAME
     &               PATH2FLUX,     ! PATH TO FLUX DATA
     &                NEWMONTH,     ! SIGNAL TO READ DATA FOR MONTHLY MEAANS
     &            IND_CLIM_TAT,     ! INDEX OF CLIMATICITY (0-CLIMATIC DATA, 1 - REAL YEAR DATA)
     &                  M_YEAR,     ! CURRENT YEAR NUMBER
     &          M_TIME_CHANGED)     ! INDICATOR OF TIME CHANGED(0-NOT,1-CHANGED) 
                                    ! 1-SEC,2-MIN,3-HOUR,4-DAY,5-MONTH,6-YEAR,7-4YRS
C READING AND TIME INTERPOLATION OF AIR TEMPERATURE  
       CALL FORC_TIME_INTERPOLATION(SS_FILES_FULLNAME(15),TAT,
     &       DAYS_IN_4YR,DAY_OF_4YR,MONTH_COUNTER,
     &       NXA,NYA,FTYPE_TAT,NEWMONTH,NDAYS_IN_4YR,M_YEAR_OF_4YR,
     &       M_MONTH_OF_4YR,NTIME_TAT,TIME_RESOLUTION_TAT, 
     &       M_DAY_OF_MONTH,M_HOUR_OF_DAY,M_TIME_CHANGED)      
      END IF
C===================================================================================

      IF(IGS.GT.2.OR.IGICE.GT.0) THEN
C  FORMING FULL FILE NAME FOR PRECIPITATION
            CALL ATM_FULL_NAME 
     &            (SS_FILES(14),     ! ORIGINAL FILE NAME
     &    SS_FILES_FULLNAME(14),     ! FULL FILE NAME
     &               PATH2FLUX,     ! PATH TO FLUX DATA
     &                NEWMONTH,     ! SIGNAL TO READ DATA FOR MONTHLY MEAANS
     &            IND_CLIM_PRAT,     ! INDEX OF CLIMATICITY (0-CLIMATIC DATA, 1 - REAL YEAR DATA)
     &                  M_YEAR,     ! CURRENT YEAR NUMBER
     &          M_TIME_CHANGED)     ! INDICATOR OF TIME CHANGED(0-NOT,1-CHANGED) 
                                    ! 1-SEC,2-MIN,3-HOUR,4-DAY,5-MONTH,6-YEAR,7-4YRS
C READING AND TIME INTERPOLATION OF PRECIPITATION  
       CALL FORC_TIME_INTERPOLATION(SS_FILES_FULLNAME(14),PRAT,
     &       DAYS_IN_4YR,DAY_OF_4YR,MONTH_COUNTER,
     &       NXA,NYA,FTYPE_PRAT,NEWMONTH,NDAYS_IN_4YR,M_YEAR_OF_4YR,
     &       M_MONTH_OF_4YR,NTIME_PRAT,TIME_RESOLUTION_PRAT, 
     &       M_DAY_OF_MONTH,M_HOUR_OF_DAY,M_TIME_CHANGED)       	
      END IF

C===================================================================================

      IF(IGS.GT.2.OR.IGT.GT.2.OR.IGICE.GT.0) THEN
C  FORMING FULL FILE NAME FOR AIR HUMIDITY
            CALL ATM_FULL_NAME 
     &            (SS_FILES(16),     ! ORIGINAL FILE NAME
     &    SS_FILES_FULLNAME(16),     ! FULL FILE NAME
     &               PATH2FLUX,     ! PATH TO FLUX DATA
     &                NEWMONTH,     ! SIGNAL TO READ DATA FOR MONTHLY MEAANS
     &            IND_CLIM_QAT,     ! INDEX OF CLIMATICITY (0-CLIMATIC DATA, 1 - REAL YEAR DATA)
     &                  M_YEAR,     ! CURRENT YEAR NUMBER
     &          M_TIME_CHANGED)     ! INDICATOR OF TIME CHANGED(0-NOT,1-CHANGED) 
                                    ! 1-SEC,2-MIN,3-HOUR,4-DAY,5-MONTH,6-YEAR,7-4YRS
C READING AND TIME INTERPOLATION OF AIR HUMIDITY  
       CALL FORC_TIME_INTERPOLATION(SS_FILES_FULLNAME(16),QAT,
     &       DAYS_IN_4YR,DAY_OF_4YR,MONTH_COUNTER,
     &       NXA,NYA,FTYPE_QAT,NEWMONTH,NDAYS_IN_4YR,M_YEAR_OF_4YR,
     &       M_MONTH_OF_4YR,NTIME_QAT,TIME_RESOLUTION_QAT, 
     &       M_DAY_OF_MONTH,M_HOUR_OF_DAY,M_TIME_CHANGED)     
	END IF

C=====================================================================================
	IF(IABS(IGWS).GT.2.OR.IGT.GT.2.OR.IGS.GT.2.OR.IGICE.GT.0) THEN
C  FORMING FULL FILE NAME FOR WIND U-SPEED
            CALL ATM_FULL_NAME 
     &            (SS_FILES(17),     ! ORIGINAL FILE NAME
     &    SS_FILES_FULLNAME(17),     ! FULL FILE NAME
     &               PATH2FLUX,     ! PATH TO FLUX DATA
     &                NEWMONTH,     ! SIGNAL TO READ DATA FOR MONTHLY MEAANS
     &            IND_CLIM_UAT,     ! INDEX OF CLIMATICITY (0-CLIMATIC DATA, 1 - REAL YEAR DATA)
     &                  M_YEAR,     ! CURRENT YEAR NUMBER
     &          M_TIME_CHANGED)     ! INDICATOR OF TIME CHANGED(0-NOT,1-CHANGED) 
                                    ! 1-SEC,2-MIN,3-HOUR,4-DAY,5-MONTH,6-YEAR,7-4YRS
C READING AND TIME INTERPOLATION OF U-SPEED  
       CALL FORC_TIME_INTERPOLATION(SS_FILES_FULLNAME(17),UAT,
     &       DAYS_IN_4YR,DAY_OF_4YR,MONTH_COUNTER,
     &       NXA,NYA,FTYPE_UAT,NEWMONTH,NDAYS_IN_4YR,M_YEAR_OF_4YR,
     &       M_MONTH_OF_4YR,NTIME_UAT,TIME_RESOLUTION_UAT, 
     &       M_DAY_OF_MONTH,M_HOUR_OF_DAY,M_TIME_CHANGED)
C=====================================================================================       
C  FORMING FULL FILE NAME FOR WIND V-SPEED
            CALL ATM_FULL_NAME 
     &            (SS_FILES(18),     ! ORIGINAL FILE NAME
     &    SS_FILES_FULLNAME(18),     ! FULL FILE NAME
     &               PATH2FLUX,     ! PATH TO FLUX DATA
     &                NEWMONTH,     ! SIGNAL TO READ DATA FOR MONTHLY MEAANS
     &            IND_CLIM_VAT,     ! INDEX OF CLIMATICITY (0-CLIMATIC DATA, 1 - REAL YEAR DATA)
     &                  M_YEAR,     ! CURRENT YEAR NUMBER
     &          M_TIME_CHANGED)     ! INDICATOR OF TIME CHANGED(0-NOT,1-CHANGED) 
                                    ! 1-SEC,2-MIN,3-HOUR,4-DAY,5-MONTH,6-YEAR,7-4YRS
C READING AND TIME INTERPOLATION OF V-SPEED  
       CALL FORC_TIME_INTERPOLATION(SS_FILES_FULLNAME(18),VAT,
     &       DAYS_IN_4YR,DAY_OF_4YR,MONTH_COUNTER,
     &       NXA,NYA,FTYPE_VAT,NEWMONTH,NDAYS_IN_4YR,M_YEAR_OF_4YR,
     &       M_MONTH_OF_4YR,NTIME_VAT,TIME_RESOLUTION_VAT, 
     &       M_DAY_OF_MONTH,M_HOUR_OF_DAY,M_TIME_CHANGED)
	END IF

      RETURN
      END

C======================================================================
C ATMOSPHERIC DATA SPATIAL INTERPOLATION FRON ATM TO OCEAN GRID
      SUBROUTINE OCFORCING(RELAXT,RELAXS,IGT,IGS,IGWS,IGICE)

	IMPLICIT NONE
      INCLUDE '0COM.INC'
      INCLUDE '1ATMFORCING.INC'
      INCLUDE '0CEAN.INC'
      INCLUDE '0FUNCDEF.INC'
C      INCLUDE '0TF.INC'
	INCLUDE '0A2OINTRP.INC'
	INCLUDE '1SEAICE.INC'
	INCLUDE '0ICEPAR.INC'

	INTEGER IGT,IGS,IGWS,IGICE

C         TYPES OF SS CONDITION FOR T,S:
C   IGT,IGS=
C         1 - FIRST CONDITION
C         (ONLY T,S AT OCEAN SURFACE ARE USED)
C         2 - SECOND CONDITION 
C         (HEAT AND FRESH WATER BALANCES ARE USED)
C         3 - THIRD CONDITION
C         (HEAT AND SALT FLUXES ARE CALCULATED BY BULK-FORMULAE)

C         TYPES OF SS CONDITION FOR U,V:
C   IGWS=
C         1 - WIND STRESS COMPONENTS ARE READ FROM FILES,
C             ATM PRESSURE DOES NOT AFFECT DYNAMICS
C         2 - WIND STRESS COMPONENTS ARE READ FROM FILES,
C             ATM PRESSURE AFFECTS DYNAMICS
C         3 - WIND STRESS COMPONENTS ARE CALCULATED BY BULK FORMULAE,
C             ATM PRESSURE DOES NOT AFFECT DYNAMICS
C         4 - WIND STRESS COMPONENTS ARE CALCULATED BY BULK FORMULAE,
C             ATM PRESSURE AFFECTS DYNAMICS

C         USAGE OF ICE BLOCK IN OCEAN MODEL:
C   IGICE=
C         0 - ICE BLOCK IS NOT USED
C         1 - ICE BLOCK IS     USED

C IAVT=  1-DO NOT REMOVE SPACE AVERAGING HEAT FLUX,
C        2-       REMOVE SPACE AVERAGING HEAT FLUX;
C IAVS=  1-DO NOT REMOVE SPACE AVERAGING WRESH WATER FLUX,
C        2-       REMOVE SPACE AVERAGING WRESH WATER FLUX.

      REAL RELAXT,RELAXS       !VALUE OF RELAXING COEFFICIENT FOR T&S[CM/S]
C      REAL S_FLUX_AVER

	INTEGER M, N     
      
      IF(IGT.GT.1.OR.IGICE.GT.0) DKFT=RELAXT    
      IF(IGS.GT.1.OR.IGICE.GT.0) DKFS=RELAXS 


      IF(IABS(IGWS).LE.2) THEN
C  SPATIAL INTERPOLATION OF MONTHLY MEAN WIND STRESS
C-------TXA,TYA - WIND STRESS
      CALL INTERPOLROT_VEC(
     &     NXA,            !NUMBER OF X-GRID POINTS(INPUT)
     &     NYA,            !NUMBER OF Y-GRID POINTS(INPUT)
     &     NX,             !NUMBER OF X-GRID POINTS(OUTPUT)
     &     NY,             !NUMBER OF Y-GRID POINTS(OUTPUT)
     &     TXA,            !INPUT ZONAL DATA ARRAY
     &     TYA,            !INPUT MERIDIONAL DATA ARRAY
     &     TAUX,           !OUTPUT ZONAL DATA ARRAY
     &     TAUY,           !OUTPUT MERIDIONAL DATA ARRAY
     &  I_INPUT_A2O,       !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  J_INPUT_A2O,       !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  WGHT_MTRX_A2O,     !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     &  ROTVEC_COEFF_A2O,  !ANGLES BETWEEN PARALLELS
     &  LU,                !SEA-LAND MASK FOR OUTPUT DATA
     &     0.0,     
     &     MMM,            !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     MM,             ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     NNN,            !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &     NN)             ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
C CONVERTING WIND STRESS TO MODEL UNITS (CM**2/S**2)	
      TAUX=TAUX*CONFAC_TAUX
	TAUY=TAUY*CONFAC_TAUY

C CICLIZING IS NEEDED FOR WIND STRESS
       IF(MMD.NE.0) THEN
          CALL CYCLIZE(TAUX,NX,NY, 1,  MMM,MM)
          CALL CYCLIZE(TAUY,NX,NY, 1,  MMM,MM)
       END IF
       
      END IF

      
      IF(IGT.EQ.2) THEN
C HEAT BALANCE =>OC T-GRID 
       CALL INTERPOLROT_SCAL(
     &     NXA,               !NUMBER OF X-GRID POINTS(INPUT)
     &     NYA,               !NUMBER OF Y-GRID POINTS(INPUT)
     &     NX,                !NUMBER OF X-GRID POINTS(OUTPUT)
     &     NY,                !NUMBER OF Y-GRID POINTS(OUTPUT)
     &     QBL,               !INPUT DATA ARRAY
     &     QBAL,              !OUTPUT DATA ARRAY
     &  I_INPUT_A2O,          !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  J_INPUT_A2O,          !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  WGHT_MTRX_A2O,        !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     &  LU,                   !SEA-LAND MASK FOR OUTPUT DATA
     &  0.0,
     &     MMM,               !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     MM,                ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     NNN,               !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &     NN)              ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)

C CONVERTING HEAT BALANCE TO MODEL UNITS (°C*CM/S)	
	 QBAL=QBAL*CONFAC_QBAL

C  SW-RADIATION BALANCE =>OC T-GRID      
       CALL INTERPOLROT_SCAL(
     &     NXA,               !NUMBER OF X-GRID POINTS(INPUT)
     &     NYA,               !NUMBER OF Y-GRID POINTS(INPUT)
     &     NX,                !NUMBER OF X-GRID POINTS(OUTPUT)
     &     NY,                !NUMBER OF Y-GRID POINTS(OUTPUT)
     &     QSW,               !INPUT DATA ARRAY
     &     QSWR,              !OUTPUT DATA ARRAY
     &  I_INPUT_A2O,          !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  J_INPUT_A2O,          !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  WGHT_MTRX_A2O,        !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     &  LU,                   !SEA-LAND MASK FOR OUTPUT DATA
     &  0.0,
     &     MMM,               !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     MM,                ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     NNN,               !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &     NN)              ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)

C CONVERTING SHORTWAVE RADIATION BALANCE TO MODEL UNITS (°C*CM/S)      
	 QSWR=QSWR*CONFAC_QSWR
	 QSWR=MAX(QSWR,0.0)	
      
      END IF


      IF(IGS.EQ.2) THEN
C FRESH WATER BALANCE  => OC T-GRID
       CALL INTERPOLROT_SCAL(
     &     NXA,               !NUMBER OF X-GRID POINTS(INPUT)
     &     NYA,               !NUMBER OF Y-GRID POINTS(INPUT)
     &     NX,                !NUMBER OF X-GRID POINTS(OUTPUT)
     &     NY,                !NUMBER OF Y-GRID POINTS(OUTPUT)
     &     PME,               !INPUT DATA ARRAY
     &     QSAL,              !OUTPUT DATA ARRAY
     &  I_INPUT_A2O,          !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  J_INPUT_A2O,          !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  WGHT_MTRX_A2O,        !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     &  LU,                   !SEA-LAND MASK FOR OUTPUT DATA
     &  0.0,
     &     MMM,               !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     MM,                ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     NNN,               !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &     NN)              ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)

C CONVERTING FRESHWATER BALANCE TO MODEL UNITS (CM/S)
	 QSAL=QSAL*CONFAC_QSAL
	
      END IF

      
      IF((IGS.GE.2.OR.IGT.GE.2).AND.IGICE.EQ.0) THEN
C   ICE MASK => OC T-GRID

       CALL INTERPOLROT_SCAL(
     &     NXA,               !NUMBER OF X-GRID POINTS(INPUT)
     &     NYA,               !NUMBER OF Y-GRID POINTS(INPUT)
     &     NX,                !NUMBER OF X-GRID POINTS(OUTPUT)
     &     NY,                !NUMBER OF Y-GRID POINTS(OUTPUT)
     &     SIC,               !INPUT DATA ARRAY
     &     SICE,              !OUTPUT DATA ARRAY
     &  I_INPUT_A2O,          !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  J_INPUT_A2O,          !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  WGHT_MTRX_A2O,        !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     &  LU,                   !SEA-LAND MASK FOR OUTPUT DATA
     &  0.0,
     &     MMM,               !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     MM,                ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     NNN,               !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &     NN)              ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)

C CONVERTING SEA ICE CONCENTRATION TO MODEL UNITS (UNDIM,[0;1])
       SICE=SICE*CONFAC_SICE
	 
       SICE=MAX(SICE,0.0)
       SICE=MIN(SICE,1.0)    
      
      END IF

      
      IF(IGT.EQ.5) THEN
C  TEMTERATURE OF ATM =>OC T-GRID 
       CALL INTERPOLROT_SCAL(
     &     NXA,               !NUMBER OF X-GRID POINTS(INPUT)
     &     NYA,               !NUMBER OF Y-GRID POINTS(INPUT)
     &     NX,                !NUMBER OF X-GRID POINTS(OUTPUT)
     &     NY,                !NUMBER OF Y-GRID POINTS(OUTPUT)
     &     TSA,               !INPUT DATA ARRAY
     &     T0B,               !OUTPUT DATA ARRAY
     &  I_INPUT_A2O,          !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  J_INPUT_A2O,          !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  WGHT_MTRX_A2O,        !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     &  LU,                   !SEA-LAND MASK FOR OUTPUT DATA
     &  0.0,
     &     MMM,               !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     MM,                ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     NNN,               !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &     NN)              ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
C CONVERTING AIR TEMPERATURE TO MODEL UNITS (°C)
	 T0B=T0B*CONFAC_T0B
	END IF

      
      IF(IGT.GT.2.OR.IGS.GT.2.OR.IGICE.GT.0.
     &          OR. IABS(IGWS).EQ.2.OR. IABS(IGWS).EQ.4) THEN
C SEA LEVEL PRESSURE =>OC T-GRID     
       CALL INTERPOLROT_SCAL(
     &     NXA,               !NUMBER OF X-GRID POINTS(INPUT)
     &     NYA,               !NUMBER OF Y-GRID POINTS(INPUT)
     &     NX,                !NUMBER OF X-GRID POINTS(OUTPUT)
     &     NY,                !NUMBER OF Y-GRID POINTS(OUTPUT)
     &     SLP,               !INPUT DATA ARRAY
     &     SLPR,              !OUTPUT DATA ARRAY
     &  I_INPUT_A2O,          !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  J_INPUT_A2O,          !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  WGHT_MTRX_A2O,        !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     &  LU,                   !SEA-LAND MASK FOR OUTPUT DATA
     &  0.0,
     &     MMM,               !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     MM,                ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     NNN,               !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &     NN)              ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)

C CONVERTING SEA LEVEL PRESSURE TO MODEL UNITS (PA)      
	 SLPR=SLPR*CONFAC_SLPR
	 SLPR=MAX(SLPR,0.0)      
       
       IF(MMD.NE.0) THEN
          CALL CYCLIZE(SLPR,NX,NY, 1,  MMM,MM)
       END IF

      END IF


      IF(IGS.GE.2.OR.IGICE.GT.0) THEN
C-------RIVER RUNOFF -       
       CALL INTERPOLROT_SCAL(
     &     NXA,               !NUMBER OF X-GRID POINTS(INPUT)
     &     NYA,               !NUMBER OF Y-GRID POINTS(INPUT)
     &     NX,                !NUMBER OF X-GRID POINTS(OUTPUT)
     &     NY,                !NUMBER OF Y-GRID POINTS(OUTPUT)
     &     ROFF,              !INPUT DATA ARRAY
     &     RUNOFF,            !OUTPUT DATA ARRAY
     &  I_INPUT_A2O,          !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  J_INPUT_A2O,          !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  WGHT_MTRX_A2O,        !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     &  LU,                   !SEA-LAND MASK FOR OUTPUT DATA
     &  0.0,
     &     MMM,               !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     MM,                ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     NNN,               !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &     NN)              ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
C CONVERTING RIVER RUNOFF TO MODEL UNITS (CM/S)       
       RUNOFF=RUNOFF*CONFAC_RUNOFF
	 RUNOFF=MAX(RUNOFF,0.0) 
	END IF
      

      IF(IGT.GT.2.OR.IGICE.GT.0) THEN
C DOWNWARD LW-RADIATION =>OC T-GRID
       CALL INTERPOLROT_SCAL(
     &     NXA,               !NUMBER OF X-GRID POINTS(INPUT)
     &     NYA,               !NUMBER OF Y-GRID POINTS(INPUT)
     &     NX,                !NUMBER OF X-GRID POINTS(OUTPUT)
     &     NY,                !NUMBER OF Y-GRID POINTS(OUTPUT)
     &     LWAT,              !INPUT DATA ARRAY
     &     LW,                !OUTPUT DATA ARRAY
     &  I_INPUT_A2O,          !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  J_INPUT_A2O,          !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  WGHT_MTRX_A2O,        !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     &  LU,                   !SEA-LAND MASK FOR OUTPUT DATA
     &  0.0,
     &     MMM,               !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     MM,                ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     NNN,               !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &     NN)              ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)

C CONVERTING DOWNWARD LW-RADIATION TO MODEL UNITS (ERG/S/CM**2)
	 LW=LW*CONFAC_LW
	 LW=MAX(LW,0.0)
        	


C DOWNWARD SW-RADIATION =>OC T-GRID    
       CALL INTERPOLROT_SCAL(
     &     NXA,               !NUMBER OF X-GRID POINTS(INPUT)
     &     NYA,               !NUMBER OF Y-GRID POINTS(INPUT)
     &     NX,                !NUMBER OF X-GRID POINTS(OUTPUT)
     &     NY,                !NUMBER OF Y-GRID POINTS(OUTPUT)
     &     SWAT,              !INPUT DATA ARRAY
     &     SW,                !OUTPUT DATA ARRAY
     &  I_INPUT_A2O,          !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  J_INPUT_A2O,          !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  WGHT_MTRX_A2O,        !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     &  LU,                   !SEA-LAND MASK FOR OUTPUT DATA
     &  0.0,
     &     MMM,               !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     MM,                ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     NNN,               !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &     NN)              ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)

C CONVERTING DOWNWARD SW-RADIATION TO MODEL UNITS (ERG/S/CM**2)      
	 SW=SW*CONFAC_SW
	 SW=MAX(SW,0.0)
      
C  TEMTERATURE OF ATM =>OC T-GRID 
       CALL INTERPOLROT_SCAL(
     &     NXA,               !NUMBER OF X-GRID POINTS(INPUT)
     &     NYA,               !NUMBER OF Y-GRID POINTS(INPUT)
     &     NX,                !NUMBER OF X-GRID POINTS(OUTPUT)
     &     NY,                !NUMBER OF Y-GRID POINTS(OUTPUT)
     &     TAT,               !INPUT DATA ARRAY
     &     TA,                !OUTPUT DATA ARRAY
     &  I_INPUT_A2O,          !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  J_INPUT_A2O,          !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  WGHT_MTRX_A2O,        !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     &  LU,                   !SEA-LAND MASK FOR OUTPUT DATA
     &  0.0,
     &     MMM,               !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     MM,                ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     NNN,               !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &     NN)              ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)

C CONVERTING AIR TEMPERATURE TO MODEL UNITS (°C)	
	 TA=TA*CONFAC_TA      
      END IF

      IF(IGS.GT.2.OR.IGICE.GT.0) THEN
C PRECIPITATION  => OC T-GRID 
       CALL INTERPOLROT_SCAL(
     &     NXA,               !NUMBER OF X-GRID POINTS(INPUT)
     &     NYA,               !NUMBER OF Y-GRID POINTS(INPUT)
     &     NX,                !NUMBER OF X-GRID POINTS(OUTPUT)
     &     NY,                !NUMBER OF Y-GRID POINTS(OUTPUT)
     &     PRAT,              !INPUT DATA ARRAY
     &     PR,                !OUTPUT DATA ARRAY
     &  I_INPUT_A2O,          !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  J_INPUT_A2O,          !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  WGHT_MTRX_A2O,        !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     &  LU,                   !SEA-LAND MASK FOR OUTPUT DATA
     &  0.0,
     &     MMM,               !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     MM,                ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     NNN,               !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &     NN)              ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)

C CONVERTING PRECIPITATION TO MODEL UNITS (CM/S)
	 PR=PR*CONFAC_PR
	 PR=MAX(PR,0.0)
	
      END IF

      IF(IGS.GT.2.OR.IGT.GT.2.OR.IGICE.GT.0) THEN
C   HUMIDITY => OC T-GRID

       CALL INTERPOLROT_SCAL(
     &     NXA,               !NUMBER OF X-GRID POINTS(INPUT)
     &     NYA,               !NUMBER OF Y-GRID POINTS(INPUT)
     &     NX,                !NUMBER OF X-GRID POINTS(OUTPUT)
     &     NY,                !NUMBER OF Y-GRID POINTS(OUTPUT)
     &     QAT,               !INPUT DATA ARRAY
     &     QA,                !OUTPUT DATA ARRAY
     &  I_INPUT_A2O,          !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  J_INPUT_A2O,          !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  WGHT_MTRX_A2O,        !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     &  LU,                   !SEA-LAND MASK FOR OUTPUT DATA
     &  0.0,
     &     MMM,               !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     MM,                ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     NNN,               !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &     NN)              ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)

C CONVERTING AIR HUMIDITY TO MODEL UNITS (UNDIM,[0;1])	 
	 QA=QA*CONFAC_QA
	 QA=MAX(QA,0.0)
	
      END IF

	
      IF(IABS(IGWS).GT.2.OR.IGT.GT.2.OR.IGS.GT.2.OR.IGICE.GT.0) THEN
C-------TXA,TYA - WIND 
      CALL INTERPOLROT_VEC(
     &     NXA,            !NUMBER OF X-GRID POINTS(INPUT)
     &     NYA,            !NUMBER OF Y-GRID POINTS(INPUT)
     &     NX,             !NUMBER OF X-GRID POINTS(OUTPUT)
     &     NY,             !NUMBER OF Y-GRID POINTS(OUTPUT)
     &     UAT,            !INPUT ZONAL DATA ARRAY
     &     VAT,            !INPUT MERIDIONAL DATA ARRAY
     &     UWND,           !OUTPUT ZONAL DATA ARRAY
     &     VWND,           !OUTPUT MERIDIONAL DATA ARRAY
     &  I_INPUT_A2O,       !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  J_INPUT_A2O,       !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  WGHT_MTRX_A2O,     !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     &  ROTVEC_COEFF_A2O,  !ANGLES BETWEEN PARALLELS
     &  LU,                !SEA-LAND MASK FOR OUTPUT DATA
     &     0.0,     
     &     MMM,            !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     MM,             ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     NNN,            !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &     NN)             ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
 
C CONVERTING WIND SPEED TO MODEL UNITS (ERG/S/CM**2)
       UWND=UWND*CONFAC_UWND
       VWND=VWND*CONFAC_VWND

C COMPUTING WIND SPEED IN HIGH LATITUDES
      IF(IGWS.LT.-2) THEN
        CALL WIND_SPEED_CORR()
	END IF



C    CALCULATING MODULO OF WIND RELATIVE SPEED
!$OMP PARALLEL DO PRIVATE(M,N)	
       DO N=NNN,NN
         DO M=MMM,MM
           IF(LU(M,N).GT.0.5)THEN
             WIND(M,N)=SQRT(
     &       ( UWND(M,N)-(UU(M,N,1)+UU(M-1,N,1))/2.0  )**2
     &       +(VWND(M,N)-(VV(M,N,1)+VV(M,N-1,1))/2.0  )**2   )
           
           END IF
         END DO
       END DO
!$OMP END PARALLEL DO

       IF(MMD.NE.0) THEN
          CALL CYCLIZE(UWND,NX,NY, 1,  MMM,MM)
          CALL CYCLIZE(VWND,NX,NY, 1,  MMM,MM)
          CALL CYCLIZE(WIND,NX,NY, 1,  MMM,MM)
       END IF

      END IF
       

      IF(IABS(IGWS).GT.2) THEN
C   CALCULATING WIND STRESS IN MODEL UNITS[CM**2/S**2]            
!$OMP PARALLEL DO PRIVATE(M,N)
       DO N=NNN,NN
         DO M=MMM,MM
           IF(LU(M,N).GT.0.5)THEN

            TAUX(M,N)=ROA*(1.1+0.0004*WIND(M,N))*0.001*WIND(M,N)
     &       *(UWND(M,N)-(UU(M,N,1)+UU(M-1,N,1))/2.0)/RH0

            TAUY(M,N)=ROA*(1.1+0.0004*WIND(M,N))*0.001*WIND(M,N)
     *       *(VWND(M,N)-(VV(M,N,1)+VV(M,N-1,1))/2.0)/RH0           
c           TAUX(M,N)=ROA*(1.1+0.0004*WIND(M,N))*0.001
c    &        *WIND(M,N)*(UWND(M,N))/RH0
c           TAUY(M,N)=ROA*(1.1+0.0004*WIND(M,N))*0.001
c    &        *WIND(M,N)*(VWND(M,N))/RH0              
           END IF
         END DO
       END DO
!$OMP END PARALLEL DO 
	END IF

C CICLIZING IS NEEDED FOR WIND STRESS 
       IF(MMD.NE.0) THEN
          CALL CYCLIZE(TAUX,NX,NY, 1,  MMM,MM)
          CALL CYCLIZE(TAUY,NX,NY, 1,  MMM,MM)
       END IF

	RETURN
      END
C====================================================================
C SUBROUTINE FOR COMPUTING WIND SPEED IN HIGH LATITUDES
      SUBROUTINE WIND_SPEED_CORR()
      IMPLICIT NONE
      
      INCLUDE '0COM.INC'
      INCLUDE '1ATMFORCING.INC'
      INCLUDE '0CEAN.INC'
	INCLUDE '0ICEPAR.INC'

      REAL RL_SOUTH,             !SOUTH BOUNDARY OF WIND BLENDING ZONE
     &     RL_NORTH              !NORTH BOUNDARY OF WIND BLENDING ZONE
	REAL GEOWNDX,GEOWNDY,GEOWNDABS
	REAL SURFWNDX,SURFWNDY
	REAL RLU_P,RLU_M,RLV_P,RLV_M, RLT

C  CONVERSION PARAMETERS FOR CONVERTING GEOSTROPHIC WIND TO SURFACE ONE
C  IF WIND SPEED >= 15 M/S      
      REAL WNDFAC_GE_15MPS,   !SCALE COEFFICIENT 
     &     WNDCOS_GE_15MPS,   !COS-ANGLE OF ROTATION 
     &     WNDSIN_GE_15MPS    !SIN-ANGLE OF ROTATION 
C  IF WIND SPEED  < 15 M/S       
      REAL WNDFAC_LT_15MPS,   !SCALE COEFFICIENT 
     &     WNDCOS_LT_15MPS,   !COS-ANGLE OF ROTATION
     &     WNDSIN_LT_15MPS    !SIN-ANGLE OF ROTATION

	INTEGER M, N

	REAL PIP180,DPIP180              !FOR DEGREES TO RADIANS CONVERS
	PARAMETER(PIP180=3.141592653/180.0,
     &         DPIP180=3.1415926535897/180.0D00)

      RL_SOUTH=2.0*OMEGA*SIN(PIP180*60.0)  !SOUTH BOUNDARY OF WIND BLENDING ZONE
      RL_NORTH=2.0*OMEGA*SIN(PIP180*65.0)  !NORTH BOUNDARY OF WIND BLENDING ZONE

C  IF WIND SPEED >= 15 M/S      
      WNDFAC_GE_15MPS=0.7        !SCALE COEFFICIENT
      WNDCOS_GE_15MPS=COS(PIP180*20.0) !COS-ANGLE OF ROTATION 
      WNDSIN_GE_15MPS=SIN(PIP180*20.0) !SIN-ANGLE OF ROTATION 
C  IF WIND SPEED  < 15 M/S      
      WNDFAC_LT_15MPS=0.8        !SCALE COEFFICIENT 
      WNDCOS_LT_15MPS=COS(PIP180*30.0) !COS-ANGLE OF ROTATION 
      WNDSIN_LT_15MPS=SIN(PIP180*30.0) !SIN-ANGLE OF ROTATION 

!$OMP PARALLEL DO PRIVATE(M,N,RLU_P,RLU_M,RLV_P,RLV_M,RLT,
!$OMP&         GEOWNDX,GEOWNDY,GEOWNDABS,SURFWNDX,SURFWNDY) 
	DO N=NNN,NN
	  DO M=MMM,MM
          IF(LU(M,N).GT.0.5) THEN
            
            RLU_P=(RLH(M  ,N)+RLH(M  ,N-1))/2.0
            RLU_M=(RLH(M-1,N)+RLH(M-1,N-1))/2.0

            RLV_P=(RLH(M,N  )+RLH(M-1,N  ))/2.0
            RLV_M=(RLH(M,N-1)+RLH(M-1,N-1))/2.0

            RLT=(RLH(M,N  )+RLH(M-1,N  )
     &       +RLH(M,N-1)+RLH(M-1,N-1))/4.0

C   IF GEOGRAPHICAL LATITUDE GREATER THAN 60° (OR OTHER)           
           IF(RLT.GE.RL_SOUTH) THEN        

C      COMPUTING ZONAL COMPONENT OF GEOSTROPHICAL WIND IN T-POINTS          
C           l * u = -1/Roa * dP/dY              
C      SLPR - PRESSURE IN Pa, 10 - CONVERSION FACTOR TO CGS UNITS
            GEOWNDX=-10.0/ROA                    
     &     * ( LCV(M,N  )*(SLPR(M,N+1)-SLPR(M,N  ))
     &        /(RLV_P*DYT(M,N  )*RN)                  

     &      +  LCV(M,N-1)*(SLPR(M,N  )-SLPR(M,N-1))
     &        /(RLV_M*DYT(M,N-1)*RN) )
     &      /MAX(LCV(M,N)+LCV(M,N-1),1.0)

C      COMPUTING MERIDIONAL COMPONENT OF GEOSTROPHICAL WIND IN T-POINTS
C         - l * v = -1/Roa * dP/dX
C      SLPR - PRESSURE IN Pa, 10 - CONVERSION FACTOR TO CGS UNITS            
            GEOWNDY= 10.0/ROA                  
     &     * ( LCU(M  ,N)*(SLPR(M+1,N)-SLPR(M  ,N))  
     &     / ( RLU_P*DXT(M  ,N)*RN)
                        
     &      +  LCU(M-1,N)*(SLPR(M  ,N)-SLPR(M-1,N))
     &     / ( RLU_M*DXT(M-1,N)*RN) )
     &      /MAX(LCU(M,N)+LCU(M-1,N),1.0)

C      COMPUTING MODULO OF GEOSTROPHICAL WIND IN T-POINTS            
	      GEOWNDABS=SQRT(GEOWNDX**2+GEOWNDY**2)

C      CONVERTING GEOSTROPHICAL WIND TO SURFACE ONE
C      BY MULTIPLYING IT BY COEFFICIENT (WNDFAC)
C      AND ROTATION AT SHIFT ANGLE

C      IF GEOSTROPHICAL WIND MODULO IS GREATER THAN 15 M/S            
            IF(GEOWNDABS.GE.1500.0) THEN
             
             SURFWNDX=    WNDFAC_GE_15MPS
     &         *( GEOWNDX*WNDCOS_GE_15MPS
     &           -GEOWNDY*WNDSIN_GE_15MPS )
             SURFWNDY=    WNDFAC_GE_15MPS
     &         *( GEOWNDX*WNDSIN_GE_15MPS
     &           +GEOWNDY*WNDCOS_GE_15MPS)

C      IF GEOSTROPHICAL WIND MODULO IS LESS THAN 15 M/S             
            ELSE
             SURFWNDX=    WNDFAC_LT_15MPS
     &         *( GEOWNDX*WNDCOS_LT_15MPS
     &           -GEOWNDY*WNDSIN_LT_15MPS )
             SURFWNDY=    WNDFAC_LT_15MPS
     &         *( GEOWNDX*WNDSIN_LT_15MPS
     &           +GEOWNDY*WNDCOS_LT_15MPS)
	      END IF

C CORRECTING WIND COMPONENTS (UWND,VWND) OBTAINED FROM NCEP DATA
C     IN HIGHER GEOGRAPHICAL LATITUDES

C IF GEOGRAPHICAL LATITUDE GREATER THAN 65° (OR OTHER, SEE 1ATMFORCING.INC)
C THE RESULTING WIND IS FULLY EQUAL TO JUST COMPUTED SURFACE ONE
            IF(RLT.GE.RL_NORTH) THEN
              UWND(M,N)=SURFWNDX
	        VWND(M,N)=SURFWNDY

C IF GEOGRAPHICAL LATITUDE LESS THAN 65° (OR OTHER, SEE 1ATMFORCING.INC)
C (THAT IS BETWEEN 60° AND 65°)
C THE RESULTING WIND IS EQUAL TO QASI-LINEAR COMBINATION OF 
C JUST COMPUTED SURWACE WIND AND NCEP DATA
            ELSE
              UWND(M,N)=
     &        UWND(M,N)*(RL_NORTH-RLT)/(RL_NORTH-RL_SOUTH)
     &      + SURFWNDX *(RLT-RL_SOUTH)/(RL_NORTH-RL_SOUTH)   
              VWND(M,N)=
     &        VWND(M,N)*(RL_NORTH-RLT)/(RL_NORTH-RL_SOUTH)
     &      + SURFWNDY *(RLT-RL_SOUTH)/(RL_NORTH-RL_SOUTH) 
            END IF
C IN RESULT WE HAVE:
C IF GEO LAT < 60°, WIND IS ENTIRELY TAKEN FROM NCEP DATA
C IF GEO LAT >=65°, WIND IS ENTIRELY TAKEN FROM JUST COMPUTED SURFACE DATA
C IF GEO LAT IS BETWEEN 60° AND 65°, WIND IS COMBINED FROM BOTH THESE DATA	     
           
           END IF
          
          END IF
        
        END DO
	END DO
!$OMP END PARALLEL DO 
	RETURN
	END

C=====================================================================
C SUBROUTINE FOR FORMING FULL FILE NAME FOR ATMOSPHERIC FORCING
      SUBROUTINE ATM_FULL_NAME 
     &               (FILENAME,     ! ORIGINAL FILE NAME
     &           FULL_FILENAME,     ! FULL FILE NAME
     &               PATH2FLUX,     ! PATH TO FLUX DATA
     &                NEWMONTH,     ! SIGNAL TO READ DATA FOR MONTHLY MEAANS
     &                IND_CLIM,     ! INDEX OF CLIMATICITY (0-CLIMATIC DATA, 1 - REAL YEAR DATA)
     &                  M_YEAR,     ! CURRENT YEAR NUMBER
     &          M_TIME_CHANGED)     ! INDICATOR OF TIME CHANGED(0-NOT,1-CHANGED) 
                                    ! 1-SEC,2-MIN,3-HOUR,4-DAY,5-MONTH,6-YEAR,7-4YRS
      IMPLICIT NONE
      
      CHARACTER*(*) PATH2FLUX,FILENAME,FULL_FILENAME
      CHARACTER FNAME*64,CHYEAR*4
      INTEGER NEWMONTH,IND_CLIM,M_YEAR,M_TIME_CHANGED(7),IERR

C FOR CLIMATIC DATA FULL FILE NAME IS FORMED ONCE THE MODEL IS STARTED
	IF(IND_CLIM.EQ.0) THEN
           IF (NEWMONTH.EQ.2) THEN
              CALL FULFNAME(FNAME,'CLIM',FILENAME,IERR)
              CALL FULFNAME(FULL_FILENAME,PATH2FLUX,FNAME,IERR)
           END IF
	ELSE
            IF(M_TIME_CHANGED(6).GT.0) THEN ! IF NEW YEAR COMES
            
	        WRITE(CHYEAR(1:4),'(I4.4)') M_YEAR
              CALL FULFNAME(FNAME,CHYEAR,FILENAME,IERR)
              CALL FULFNAME(FULL_FILENAME,PATH2FLUX,FNAME,IERR)
            END IF
      END IF
      
      
      RETURN
      END
C===========================================================
C SUBROUTINE FOR CHOOSING TYPE OF TIME INTERPOLATION FOR
C ATMOSPHERIC DATA. MAY BE MONTLY MEAN OR REAL-TIME
      SUBROUTINE FORC_TIME_INTERPOLATION(FILENAME,FIELD,
     & DAYS_IN_4YR,DAY_OF_4YR,MONTH_COUNTER,
     & NXA,NYA,FTYPE,NEWMONTH,NDAYS_IN_4YR,M_YEAR_OF_4YR,
     & M_MONTH_OF_4YR,NTIME,TIME_RESOLUTION, 
     & M_DAY_OF_MONTH,M_HOUR_OF_DAY,M_TIME_CHANGED)
        IMPLICIT NONE
      
      CHARACTER*(*) FILENAME !ATMOSPHERIC FORCING DATA FILE 
      REAL DAYS_IN_4YR(49), !DAY DISTRIBUTION IN 4-YEAR
     & DAY_OF_4YR !THE PRESENT DAY OF 4-YEAR PERIODICITY
     & 
      INTEGER NXA,NYA,NTIME !ITS DIMENSIONS
        INTEGER NDAYS_IN_4YR(0:48),
     & M_YEAR_OF_4YR,
     & M_MONTH_OF_4YR,
     & M_DAY_OF_MONTH,
     & M_TIME_CHANGED(7) !INDICATOR OF TIME CHANGED (0-NOT,1-CHANGED) FOR
                                 !1-SEC,2-MIN,3-HOUR,4-DAY,5-MONTH,6-YEAR,7-4YRS
      REAL FIELD(NXA,NYA,NTIME) 
      INTEGER FTYPE,
     & TIME_RESOLUTION 

      INTEGER MONTH_COUNTER, !THE PRESENT MONTH IN 4-YEAR
     & NEWMONTH, !COMMAND TO READING DATA(>1-Y,0-NO)
     & M_HOUR_OF_DAY
     

      IF(FTYPE.EQ.0) THEN
        CALL AMONINT(FILENAME,FIELD,DAYS_IN_4YR,DAY_OF_4YR,
     & MONTH_COUNTER,NXA,NYA,NTIME,NEWMONTH)
        ELSE 
        CALL ATM_REALTIME_INTERPOLATION
     & (FILENAME,FIELD,NDAYS_IN_4YR,M_YEAR_OF_4YR,
     & M_MONTH_OF_4YR,NXA,NYA,NTIME,
     & TIME_RESOLUTION,M_TIME_CHANGED,
     & M_DAY_OF_MONTH,M_HOUR_OF_DAY)

      END IF


        RETURN
        END
C======================================================================
C SUBROUTINE FOR INTERPOLATION OF ATMOSPHERIC FORCING FROM MONTH MEAN
C DATA ON  FIELD OF ASSIGNED STEP
      SUBROUTINE AMONINT(FILENAME,AFORC,DAYS_IN_4YR,
     &                   DAY_OF_4YR,MONTH_COUNTER,NXA,NYA,NOFMONTH,
     &                   NEWMONTH)
	IMPLICIT NONE
      INCLUDE '1LREC.INC'       !SET LONG OF UNIQUE RECL
C EXTERNAL PARAMETERS
      CHARACTER*(*) FILENAME           !ATMOSPHERIC FORCING DATA FILE 
      REAL DAYS_IN_4YR(49), !DAY DISTRIBUTION IN 4-YEAR
     &     DAY_OF_4YR       !THE PRESENT DAY OF 4-YEAR PERIODICITY
      INTEGER    NXA,NYA,NOFMONTH         !ITS DIMENSIONS
      REAL       AFORC(NXA,NYA,NOFMONTH)  !ATMOSPHERIC FORCING ARRAY
      INTEGER    MONTH_COUNTER,       !THE PRESENT MONTH IN 4-YEAR
     &           NEWMONTH             !COMMAND TO READING DATA(>1-Y,0-NO)
C WEIGHT MONTH COEFFICIENTS FOR IN-MONTH INTERPOLATION:
      REAL WMCPREVIOUS,WMCPRESENT,WMCNEXT
C MONTH NUMBERS FOR READING FROM FILENAME:
      INTEGER  MONTHPREVIOUS,MONTHPRESENT,MONTHNEXT
      INTEGER  M, N
	INTEGER  KMPREVIOUS, KMPRESENT, KMNEXT

C INTERNAL PARAMETERS
      INTEGER KAFORC,          !CYCLE OF INTERPOLATION
     &        MONTH            !THE PRESENT MONTH IN THE PRESENT YEAR

C   THE PRESENT MONTH OF YEAR:
C          MONTH   =  MONTH_COUNTER-12*INT(FLOAT(MONTH_COUNTER)/12.1)
           MONTH   =  MOD(MONTH_COUNTER,12)
       IF (MONTH.EQ.0) THEN
           MONTH   = 12
       ENDIF


       KAFORC=MOD(MONTH,3)


           MONTHPREVIOUS=MONTH-1
       IF (MONTHPREVIOUS.EQ.0) THEN
           MONTHPREVIOUS = 12
       ENDIF

           MONTHPRESENT =MONTH

           MONTHNEXT    =MONTH+1
       IF (MONTHNEXT.EQ.13) THEN
           MONTHNEXT =   1
       ENDIF

C DEFINING WEIGHT COEFFICIENTS AND MONTH TO READ
      CALL MWCOEFR(DAYS_IN_4YR,DAY_OF_4YR,MONTH_COUNTER,
     &                   WMCPREVIOUS,WMCPRESENT,WMCNEXT,
     &                    KMPREVIOUS, KMPRESENT, KMNEXT)

      KMPREVIOUS = KMPREVIOUS+1   !PUTTING TO ACCORDANCE WITH
      KMPRESENT  = KMPRESENT +1   !NUMBERING OF MONTH LEVEL
      KMNEXT     = KMNEXT    +1   !IN ARFOC-ARRAY

      IF  (NEWMONTH.GE.1) THEN
      OPEN (17,FILE=FILENAME,STATUS='OLD',ACCESS='DIRECT',
     &      FORM='UNFORMATTED',RECL=(NXA-2)*(NYA-1)*LRECL,ERR=17)

      IF  (NEWMONTH.GE.2) THEN
C READ PREVIOUS AND PRESENT MONTH DATA
      WRITE(*,'(1X,A,2I7)') '  READ DATA FOR 1-ST STEP FROM: ',
     &                      MONTHPREVIOUS,MONTHPRESENT
      WRITE(*,'(5X,A)') FILENAME(1:LEN_TRIM (FILENAME))

      READ(17,REC=MONTHPREVIOUS,ERR=19)
     &                   ((AFORC(M,N,KMPREVIOUS),M=2,NXA-1),N=2,NYA)
      READ(17,REC=MONTHPRESENT, ERR=19)
     &                   ((AFORC(M,N,KMPRESENT ),M=2,NXA-1),N=2,NYA)
      END IF

C READ NEXT MONTH DATA
      WRITE(*,'(1X,A,I7)') '  READ DATA FOR NEXT MONTH: ',MONTHNEXT
      WRITE(*,'(5X,A)') FILENAME(1:LEN_TRIM (FILENAME))
      READ(17,REC=MONTHNEXT,ERR=19)
     &                   ((AFORC(M,N,KMNEXT),M=2,NXA-1),N=2,NYA)

      CLOSE(17)
      END IF


         DO N = 1,NYA
      DO M = 1,NXA
       AFORC(M,N,1)= WMCPREVIOUS*AFORC(M,N,KMPREVIOUS)+
     +               WMCPRESENT *AFORC(M,N,KMPRESENT)+
     +               WMCNEXT    *AFORC(M,N,KMNEXT)
      ENDDO
         ENDDO

      RETURN
17    WRITE(*,'(1X,A)')'   ERROR IN OPENING FILE:'
      WRITE(*,'(5X,A)') FILENAME(1:LEN_TRIM(FILENAME))
      STOP
19    WRITE(*,'(1X,A)')'   ERROR IN READING FILE:'
      WRITE(*,'(5X,A)') FILENAME(1:LEN_TRIM(FILENAME))
      STOP
      END
C===================================================
C  SUBROUTINE FOR INTERPOLATION OF DAILY ATMOSPHERIC FORCING
C  ON FIELD OF ASSIGNED STEP

      SUBROUTINE ATM_REALTIME_INTERPOLATION
     &       (FILENAME,FIELD,NDAYS_IN_4YR,M_YEAR_OF_4YR,
     &       M_MONTH_OF_4YR,NXA,NYA,NTIME,
     &       TIME_RESOLUTION,M_TIME_CHANGED,
     &       M_DAY_OF_MONTH,M_HOUR_OF_DAY)  
      
      IMPLICIT NONE
      INCLUDE '1LREC.INC'       !SET LONG OF UNIQUE RECL
C EXTERNAL PARAMETERS
      CHARACTER*(*) FILENAME         !ATMOSPHERIC FORCING DATA FILE 
      INTEGER NDAYS_IN_4YR(0:48),    !DAY DISTRIBUTION IN 4-YEAR
     &        M_YEAR_OF_4YR,         !THE PRESENT DAY OF 4-YEAR PERIODICITY
     &        M_MONTH_OF_4YR,        !THE PRESENT MONTH IN 4-YEAR
     &        M_DAY_OF_MONTH,        !THE PRESENT DAY OF MONTH
     &        M_HOUR_OF_DAY,     !THE PRESENT HOUR OF DAY 
     &        M_TIME_CHANGED(7)  !INDICATOR OF TIME CHANGED (0-NOT,1-CHANGED) FOR
                                 !1-SEC,2-MIN,3-HOUR,4-DAY,5-MONTH,6-YEAR,7-4YRS

      INTEGER    NXA,NYA,NTIME,TIME_RESOLUTION         !ITS DIMENSIONS
      REAL       FIELD(NXA,NYA,NTIME) !ATMOSPHERIC FORCING ARRAY   
      INTEGER M,N,K, NUMOFREC1,NUMOFREC2,NREC_CURRENT
      
            IF  (M_TIME_CHANGED(5).GE.1) THEN
             OPEN (17,FILE=FILENAME,STATUS='OLD',ACCESS='DIRECT',
     &         FORM='UNFORMATTED',RECL=(NXA-2)*(NYA-1)*LRECL,ERR=117)

               NUMOFREC1=(NDAYS_IN_4YR( M_MONTH_OF_4YR-1   )
     &                   -NDAYS_IN_4YR((M_YEAR_OF_4YR-1)*12) )
     &                   *24/TIME_RESOLUTION       + 1

               NUMOFREC2=(NDAYS_IN_4YR( M_MONTH_OF_4YR     )
     &                   -NDAYS_IN_4YR((M_YEAR_OF_4YR-1)*12) )
     &                   *24/TIME_RESOLUTION

      
            WRITE(*,'(1X,A,2I7)') 'READ REAL-TIME DATA FROM RECORDS: ',
     &                      NUMOFREC1,NUMOFREC2
            WRITE(*,'(5X,A)') FILENAME(1:LEN_TRIM (FILENAME))       
       
             DO K=NUMOFREC1,NUMOFREC2
              READ(17,REC=K,ERR=119)
     &                   ((FIELD(M,N,K-NUMOFREC1+3),M=2,NXA-1),N=2,NYA)
             END DO

             CLOSE(17)
            END IF

      
      NREC_CURRENT=(M_DAY_OF_MONTH-1)*24/TIME_RESOLUTION
     &            +(M_HOUR_OF_DAY-1)    /TIME_RESOLUTION +1
      FIELD(:,:,1)=FIELD(:,:,NREC_CURRENT+2)             
	
c      WRITE(*,*) 'FILE ',FILENAME,
c     *           ' NUMBER OF REALTIME RECORD ',NREC_CURRENT       

	RETURN
117    WRITE(*,'(1X,A)')'   ERROR IN OPENING FILE:'
      WRITE(*,'(5X,A)') FILENAME(1:LEN_TRIM(FILENAME))
      STOP
119    WRITE(*,'(1X,A)')'   ERROR IN READING FILE:'
      WRITE(*,'(5X,A)') FILENAME(1:LEN_TRIM(FILENAME))
      STOP	
      
      END

C=====================================================================
      SUBROUTINE WEIGHT_MATRIX_INTRP_VEC(
     &     XIN,            !ARRAY OF X-GRID VALUES (INPUT) 
     &     YIN,            !ARRAY OF Y-GRID VALUES (INPUT)
     &    NXIN,            !NUMBER OF X-GRID POINTS(INPUT)
     &    NYIN,            !NUMBER OF Y-GRID POINTS(INPUT)
     &    XOUT,            !ARRAY OF X-GRID VALUES (OUTPUT)
     &    YOUT,            !ARRAY OF Y-GRID VALUES (OUTPUT)
     &   NXOUT,            !NUMBER OF X-GRID POINTS(OUTPUT)
     &   NYOUT,            !NUMBER OF Y-GRID POINTS(OUTPUT)
     &   MASKIN,           !INPUT SEA-LAND MASK
     &   MASKOUT,          !OUTPUT SEA-LAND MASK
     & I_INPUT,            !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & J_INPUT,            !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & MATRX_ELMNT_INTRP,  !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     & ROTVEC_COEFF,       !COS AND SIN OF ANGLES BETWEEN PARALLELS
     & LAMBDA_ROT,         !ANGLE OF ROTATION ON LONGITUDE
     & PHI_ROT,            !ANGLE OF ROTATION ON LATITUDE
     & INDPER,             !INDEX OF PERIODICITY:=0 -NONPERIODIC,=1 -PERIODIC CASE
     & FILLMISS,           !FILLING MISSED VALUES (0-NO, 1-YES)
     &         MMM_IN,     !FIRST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &          MM_IN,     ! LAST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &         NNN_IN,     !FIRST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &          NN_IN,     ! LAST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &         MMM_OUT,    !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &          MM_OUT,    ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &         NNN_OUT,    !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &          NN_OUT)    ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
                        


     	
CCCCC  DEFINITION OF DATA PARAMETERS
      IMPLICIT NONE

	INCLUDE '0CRDFNC.INC'

	INTEGER INDPER !INDEX OF PERIODICITY:=0 -NONPERIODIC,=1 -PERIODIC CASE
	
	INTEGER NXIN,NYIN,NXOUT,NYOUT,FILLMISS

	INTEGER MASKIN(NXIN,NYIN)
      REAL(4) MASKOUT(NXOUT,NYOUT)

	INTEGER I_INPUT(NXOUT,NYOUT,4), !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &        J_INPUT(NXOUT,NYOUT,4)  !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID

	REAL(4) MATRX_ELMNT_INTRP(NXOUT,NYOUT,4)

	REAL(4) ROTVEC_COEFF(NXOUT,NYOUT,4)

	REAL(4) SUM_MATR_ELMNT,SUM_ROTVEC_COEFF

	REAL(4) XIN(NXIN), YIN(NYIN)                	!INPUT GRID

	REAL(4) XOUT(NXOUT), YOUT(NYOUT)            	!OUTPUT GRID
	
	REAL(4) LAMBDA_ROT,PHI_ROT                  	!PARAMETERS OF ROTATION

	REAL(8) DELTA_LEFT,DELTA_RIGHT

	REAL(8) RET_LON, RET_LAT                     	!REVERSE ROTATION

	REAL(8) FREE_MEMBER_COSLON,FREE_MEMBER_SINLON

	REAL(8) SIN_LON, SIN_LAT, COS_LON, COS_LAT   	!AUXILARY VARIABLES

	INTEGER I_NES,J_NES                             !AUXILARY INDEXES

	INTEGER I_LEFT,I_RIGHT,J_DOWN,J_UP              !AUXILARY INDEXES

	INTEGER I,J,K,M,N

	REAL(8) LAT_EXTR,COSLAT_EXTR,SINLAT_EXTR

	REAL(8) BILIN_DENOM

	REAL(8) X_LEFT,X_RIGHT,Y_DOWN,Y_UP

      REAL(8), ALLOCATABLE:: XINP(:),YINP(:), !RECALCULATED GRID FOR PERIODIC CASE
     &                       TEMP(:)
	
      INTEGER MMM_IN,  MM_IN,  NNN_IN,  NN_IN, 
     &        MMM_OUT, MM_OUT, NNN_OUT, NN_OUT

	REAL    PIP180 
      REAL(8) DPIP180              !FOR DEGREES TO RADIANS CONVERS
	PARAMETER(PIP180=3.141592653/180.0,
     &         DPIP180=3.1415926535897/180.0D00)

      LAT_EXTR = 89.9999

	COSLAT_EXTR = DCOS(DPIP180*LAT_EXTR)

	SINLAT_EXTR = DSIN(DPIP180*LAT_EXTR)

C---------INPUT GRID ANALYSIS ON PERIODICITY----------------------

      IF(INDPER.NE.1.AND.INDPER.NE.0) THEN
	   WRITE (*,*) 
     &'WRONG INDEX OF PERIODICITY IN SUBROUTINE WEIGHT_MATRIX_INTRP'
	   STOP 
	ENDIF
	
		ALLOCATE (XINP(NXIN+INDPER),YINP(NYIN),TEMP(4))
C NEW LON AND LAT GRID DEFINITION

	     XINP(MMM_IN:MM_IN)=DBLE(XIN(MMM_IN:MM_IN))
           IF(INDPER.EQ.1) XINP(MM_IN+1)=DBLE(XIN(MMM_IN))+360D0 !COMPLETING OF LONGITUDE
	     
		 YINP=DBLE(YIN)

		 YINP(:)=DMIN1(YINP(:), LAT_EXTR)
	     YINP(:)=DMAX1(YINP(:),-LAT_EXTR)

CCCCCC INTERPOLATION FROM INPUT TO OUTPUT GRID
	DO J=NNN_OUT,NN_OUT
	 DO I=MMM_OUT,MM_OUT
          
          YOUT(J)=MIN(YOUT(J), SNGL(LAT_EXTR))
	    YOUT(J)=MAX(YOUT(J),-SNGL(LAT_EXTR))	 
	 

        
	  IF (MASKOUT(I,J).GT.0.5) THEN

	   !REVERSE ROTATION
	    SIN_LAT = DSIN(DPIP180*DBLE(YOUT(J))) * 
     &              DCOS(DPIP180*DBLE(PHI_ROT)) +
     &              DCOS(DPIP180*DBLE(XOUT(I))) *
     &              DCOS(DPIP180*DBLE(YOUT(J))) *
     &              DSIN(DPIP180*DBLE(PHI_ROT))

	    SIN_LAT = DMIN1(SIN_LAT, SINLAT_EXTR)
	    SIN_LAT = DMAX1(SIN_LAT,-SINLAT_EXTR)

	    COS_LAT = DSQRT(1D0-SIN_LAT**2)
	    COS_LAT = DMAX1(COS_LAT, COSLAT_EXTR)
        
	    RET_LAT = DASIN(SIN_LAT)/DPIP180
	    RET_LAT = DMIN1(RET_LAT, LAT_EXTR)
	    RET_LAT = DMAX1(RET_LAT,-LAT_EXTR)


C         NESSESARY LATITUDE
	    FREE_MEMBER_COSLON =( DCOS(DPIP180*DBLE(XOUT(I))) *
     &                          DCOS(DPIP180*DBLE(YOUT(J))) *
     &                          DCOS(DPIP180*DBLE(PHI_ROT)) -
     &                          DSIN(DPIP180*DBLE(YOUT(J))) *
     &                          DSIN(DPIP180*DBLE(PHI_ROT))   )/COS_LAT

	    FREE_MEMBER_SINLON =( DSIN(DPIP180*DBLE(XOUT(I))) *
     &                          DCOS(DPIP180*DBLE(YOUT(J))) )/COS_LAT
	    
		COS_LON=FREE_MEMBER_COSLON*DCOS(DPIP180*DBLE(LAMBDA_ROT))
     &           -FREE_MEMBER_SINLON*DSIN(DPIP180*DBLE(LAMBDA_ROT))

		SIN_LON=FREE_MEMBER_SINLON*DCOS(DPIP180*DBLE(LAMBDA_ROT))
     &           +FREE_MEMBER_COSLON*DSIN(DPIP180*DBLE(LAMBDA_ROT))
	   
	    SIN_LON=DMIN1(SIN_LON, 1.0D0)
	    SIN_LON=DMAX1(SIN_LON,-1.0D0)
	    COS_LON=DMIN1(COS_LON, 1.0D0)
	    COS_LON=DMAX1(COS_LON,-1.0D0)

C         NESSESARY LONGITUDE
          RET_LON=DSIGN(DACOS(COS_LON)/DPIP180,SIN_LON)

C          CORRECTIONS

            IF(INDPER.EQ.1) THEN
	        IF(RET_LON .GT. XINP(MM_IN+1)) RET_LON=RET_LON-360D0
	        IF(RET_LON .LT. XINP(MMM_IN) ) RET_LON=RET_LON+360D0
            ELSE
              
              IF(RET_LON .GT. XINP(MM_IN)) THEN
	         DELTA_RIGHT=RET_LON-XINP(MM_IN)
	         RET_LON=RET_LON-360D0
               DELTA_LEFT=XIN(MMM_IN)-RET_LON
	         IF(DELTA_LEFT .GT. DELTA_RIGHT) RET_LON=RET_LON+360D0
	         GO TO 111
	        END IF

              IF(RET_LON .LT. XINP(MMM_IN)) THEN
	         DELTA_LEFT=XINP(MMM_IN)-RET_LON
	         RET_LON=RET_LON+360D0
 	         DELTA_RIGHT=RET_LON-XINP(MM_IN)
	         IF(DELTA_RIGHT .GT. DELTA_LEFT) RET_LON=RET_LON-360D0
	         GO TO 111
	        END IF
               	       
            END IF

111	 CONTINUE
C       IDENTIFICATION OF REVERSLY ROTATED POINT ON GEOGRAFIC GRID  
       
        I_NES=MMM_IN
	 
	   N=MM_IN+INDPER

1000     M=(I_NES+N)/2	 
	     
           IF (RET_LON.LT.XINP(M)) N=M
	     IF (RET_LON.GE.XINP(M)) I_NES=M
	     IF (N.GT.I_NES+1) GOTO 1000
	 
         I_LEFT =I_NES
	   I_RIGHT=I_NES+1
         IF((MM_IN-MMM_IN+1).EQ.1)I_RIGHT=I_NES

	   J_NES=NNN_IN
	   N=NN_IN
1001     M=(J_NES+N)/2	 
	     
           IF (RET_LAT.LT.YINP(M)) N=M
	     IF (RET_LAT.GE.YINP(M)) J_NES=M
	     IF (N.GT.J_NES+1) GOTO 1001
        
	   J_DOWN = J_NES
         J_UP   = J_NES+1
         IF((NN_IN-NNN_IN+1).EQ.1)J_UP=J_NES

C       MAIN BILINEAR INTERPOLATION

C--------------DEFINITION OF OUTPUT I-INDEXES AND PREPARING OF MATRIX CALCULATING----

1982     IF((I_LEFT .LT.MMM_IN)   .AND.(INDPER.EQ.1)) THEN
          
          I_INPUT(I,J,1)= I_LEFT + (MM_IN-MMM_IN+1)
	    I_INPUT(I,J,3)= I_LEFT + (MM_IN-MMM_IN+1)

	    X_LEFT = XINP(I_INPUT(I,J,1))-360D0

         ELSE
          
	    I_INPUT(I,J,1)=I_LEFT
          I_INPUT(I,J,3)=I_LEFT

          X_LEFT =XINP(I_INPUT(I,J,1))

	   END IF
	            
	   
	   IF((I_RIGHT.GT.MM_IN).AND.(INDPER.EQ.1)) THEN
          
		I_INPUT(I,J,2)=I_RIGHT-(MM_IN-MMM_IN+1)
		I_INPUT(I,J,4)=I_RIGHT-(MM_IN-MMM_IN+1)

		X_RIGHT=XINP(I_INPUT(I,J,2))+360D0
	   
	   ELSE
          
		I_INPUT(I,J,2)=I_RIGHT
		I_INPUT(I,J,4)=I_RIGHT

          X_RIGHT=XINP(I_INPUT(I,J,2))
	   
	   END IF

C--------------DEFINITION OF OUTPUT J-INDEXES--------------
	   J_INPUT(I,J,1)=J_DOWN
	   J_INPUT(I,J,2)=J_DOWN
	   J_INPUT(I,J,3)=J_UP
	   J_INPUT(I,J,4)=J_UP

	   Y_DOWN =YINP(J_INPUT(I,J,1))
	   Y_UP   =YINP(J_INPUT(I,J,3))

C---------IF ALL 4 POINTS ARE UNDEFINED MOVING BOUNDS OF RECTANGLE	   
	   IF((MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1))*
     &       MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2))*
     &       MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3))*
     &       MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4))).NE.0) THEN

           IF(FILLMISS.EQ.0) THEN
           MATRX_ELMNT_INTRP(I,J,1:4)=0.25
           ROTVEC_COEFF(I,J,1)=1.0
           ROTVEC_COEFF(I,J,2)=0.0
	     GO TO 501
	     END IF

           IF (INDPER.EQ.0) THEN

              IF ((I_LEFT.EQ.MMM_IN).AND.(I_RIGHT.EQ.MM_IN).AND.
     &            (J_DOWN.EQ.NNN_IN).AND.(J_UP   .EQ.NN_IN)) GO TO 1941

	        IF ((I_LEFT.EQ.MMM_IN).AND.(I_RIGHT.EQ.MM_IN)) THEN
	          IF (J_DOWN .GE.(NNN_IN+1)) J_DOWN=J_DOWN-1
	          IF (J_UP   .LE.( NN_IN-1)) J_UP  =J_UP  +1
	          I_LEFT =I_NES+1
	          I_RIGHT=I_NES
	        END IF

		  IF (I_LEFT .GE.(MMM_IN+1)) I_LEFT =I_LEFT -1
	        IF (I_RIGHT.LE.( MM_IN-1)) I_RIGHT=I_RIGHT+1
		 
		 ELSE
              
			IF (((I_RIGHT-I_LEFT).GE.(MM_IN-MMM_IN+1)).AND.
     &            (J_DOWN.EQ.NNN_IN).AND.(J_UP   .EQ.NN_IN)) GO TO 1941		 
		 				        
              IF((I_RIGHT-I_LEFT).GE.(MM_IN-MMM_IN+1)) THEN
	          IF (J_DOWN .GE.(NNN_IN+1)) J_DOWN=J_DOWN-1
	          IF (J_UP   .LE.( NN_IN-1)) J_UP  =J_UP  +1
	          I_LEFT =I_NES+1
	          I_RIGHT=I_NES
	        END IF  	        
			
              IF((I_RIGHT-I_LEFT).LT.(MM_IN-MMM_IN+1)) THEN
                  I_LEFT =I_LEFT -1
                  I_RIGHT=I_RIGHT+1
	        END IF

		 END IF
	     
		 GO TO 1982
	   
	   END IF
C---------END OF MOVING BOUNDS OF RECTANGLE--------------------------

	 
	   BILIN_DENOM= 1D0

	   IF (X_RIGHT .NE.X_LEFT) 
     &       BILIN_DENOM=BILIN_DENOM/
     &      (FNCLON(X_RIGHT)-FNCLON(X_LEFT))

	   IF (Y_UP    .NE.Y_DOWN)
     &       BILIN_DENOM=BILIN_DENOM/
     &      (FNCLAT(Y_UP)   -FNCLAT(Y_DOWN))
	 	 
	   TEMP=BILIN_DENOM


	    IF (X_RIGHT .NE.X_LEFT) THEN

           TEMP(1)= TEMP(1)*(FNCLON(X_RIGHT) - FNCLON(RET_LON))
     
           TEMP(2)= TEMP(2)*(FNCLON(RET_LON) - FNCLON(X_LEFT) )
		 	 
	     TEMP(3)= TEMP(3)*(FNCLON(X_RIGHT) - FNCLON(RET_LON)) 
     
	     TEMP(4)= TEMP(4)*(FNCLON(RET_LON) - FNCLON(X_LEFT) )

          END IF


		IF (Y_UP    .NE.Y_DOWN) THEN

           TEMP(1)= TEMP(1)*(FNCLAT(Y_UP)    - FNCLAT(RET_LAT))
     
           TEMP(2)= TEMP(2)*(FNCLAT(Y_UP)    - FNCLAT(RET_LAT))
		 	 
	     TEMP(3)= TEMP(3)*(FNCLAT(RET_LAT) - FNCLAT(Y_DOWN) ) 
     
	     TEMP(4)= TEMP(4)*(FNCLAT(RET_LAT) - FNCLAT(Y_DOWN) )

          END IF


C---------- PROCEDURE IF 4 POINTS ARE DEFINED---------	  
	    IF((MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1))+
     &        MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2))+
     &        MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3))+
     &        MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4))).EQ.0) THEN
	     	
			DO K=1,4
		     MATRX_ELMNT_INTRP(I,J,K)=SNGL(TEMP(K))
	        END DO
C----------END OF PROCEDURE IF 4 POINTS ARE DEFINED---------

	    ELSE
C---------- PROCEDURE IF 3 POINTS ARE DEFINED---------
	       IF((MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1))+
     &           MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2))+
     &           MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3))+
     &           MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4))).EQ.1) THEN


	         !THE 1-ST POINT IS UNDEFINED
		     IF(MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1)).EQ.1) THEN
	            MATRX_ELMNT_INTRP(I,J,1)=0.0
	            MATRX_ELMNT_INTRP(I,J,2)=SNGL(TEMP(2)+TEMP(1))
	            MATRX_ELMNT_INTRP(I,J,3)=SNGL(TEMP(3)+TEMP(1))
	            MATRX_ELMNT_INTRP(I,J,4)=SNGL(TEMP(4)-TEMP(1))
               END IF
	 
	         !THE 2-ND POINT IS UNDEFINED
	         IF(MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2)).EQ.1) THEN
	            MATRX_ELMNT_INTRP(I,J,1)=SNGL(TEMP(1)+TEMP(2))
	            MATRX_ELMNT_INTRP(I,J,2)=0.0
	            MATRX_ELMNT_INTRP(I,J,3)=SNGL(TEMP(3)-TEMP(2))
	            MATRX_ELMNT_INTRP(I,J,4)=SNGL(TEMP(4)+TEMP(2))
	         END IF
	
	         !THE 3-RD POINT IS UNDEFINED
	         IF(MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3)).EQ.1) THEN
	            MATRX_ELMNT_INTRP(I,J,1)=SNGL(TEMP(1)+TEMP(3))
	            MATRX_ELMNT_INTRP(I,J,2)=SNGL(TEMP(2)-TEMP(3))
	            MATRX_ELMNT_INTRP(I,J,3)=0.0
	            MATRX_ELMNT_INTRP(I,J,4)=SNGL(TEMP(4)+TEMP(3))
			 END IF

	         !THE 4-TH POINT IS UNDEFINED	       
		     IF(MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4)).EQ.1) THEN
	            MATRX_ELMNT_INTRP(I,J,1)=SNGL(TEMP(1)-TEMP(4))
	            MATRX_ELMNT_INTRP(I,J,2)=SNGL(TEMP(2)+TEMP(4))
	            MATRX_ELMNT_INTRP(I,J,3)=SNGL(TEMP(3)+TEMP(4))
	            MATRX_ELMNT_INTRP(I,J,4)=0.0
		     END IF 
C----------END OF PROCEDURE IF 3 POINTS ARE DEFINED---------
		 
		   ELSE
C---------- PROCEDURE IF 2 POINTS ARE DEFINED---------
	          IF((MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1))+
     &              MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2))+
     &              MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3))+
     &              MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4))).EQ.2) THEN
	
	         !THE 1-ST AND THE 2-ND POINTS ARE UNDEFINED		   
		     IF((MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1)).EQ.1).AND.
     &            (MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2)).EQ.1)) THEN
	             MATRX_ELMNT_INTRP(I,J,1)=0.0
	             MATRX_ELMNT_INTRP(I,J,2)=0.0
	             MATRX_ELMNT_INTRP(I,J,3)=SNGL(TEMP(1)+TEMP(3))
	             MATRX_ELMNT_INTRP(I,J,4)=SNGL(TEMP(2)+TEMP(4))
	         END IF

	         !THE 1-ST AND THE 3-RD POINTS ARE UNDEFINED
		     IF((MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1)).EQ.1).AND.
     &            (MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3)).EQ.1)) THEN
	             MATRX_ELMNT_INTRP(I,J,1)=0.0
	             MATRX_ELMNT_INTRP(I,J,2)=SNGL(TEMP(1)+TEMP(2))
	             MATRX_ELMNT_INTRP(I,J,3)=0.0
	             MATRX_ELMNT_INTRP(I,J,4)=SNGL(TEMP(3)+TEMP(4))
	         END IF

	         !THE 3-RD AND THE 4-TH POINTS ARE UNDEFINED		   
		     IF((MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3)).EQ.1).AND.
     &            (MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4)).EQ.1)) THEN
	             MATRX_ELMNT_INTRP(I,J,1)=SNGL(TEMP(1)+TEMP(3))
	             MATRX_ELMNT_INTRP(I,J,2)=SNGL(TEMP(2)+TEMP(4))
	             MATRX_ELMNT_INTRP(I,J,3)=0.0
	             MATRX_ELMNT_INTRP(I,J,4)=0.0
	         END IF

	         !THE 4-TH AND THE 2-ND POINTS ARE UNDEFINED
		     IF((MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4)).EQ.1).AND.
     &            (MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2)).EQ.1)) THEN
	             MATRX_ELMNT_INTRP(I,J,1)=SNGL(TEMP(1)+TEMP(2))
	             MATRX_ELMNT_INTRP(I,J,2)=0.0
	             MATRX_ELMNT_INTRP(I,J,3)=SNGL(TEMP(3)+TEMP(4))
	             MATRX_ELMNT_INTRP(I,J,4)=0.0
	         END IF

	         !THE 1-ST AND THE 4-TH POINTS ARE UNDEFINED
		     IF((MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1)).EQ.1).AND.
     &            (MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4)).EQ.1)) THEN
	             MATRX_ELMNT_INTRP(I,J,1)=0.0
	             MATRX_ELMNT_INTRP(I,J,2)=SNGL(TEMP(1)+TEMP(2))
	             MATRX_ELMNT_INTRP(I,J,3)=SNGL(TEMP(3)+TEMP(4))
	             MATRX_ELMNT_INTRP(I,J,4)=0.0
	         END IF

	         !THE 2-ND AND THE 3-RD POINTS ARE UNDEFINED
		     IF((MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3)).EQ.1).AND.
     &            (MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2)).EQ.1)) THEN
                   MATRX_ELMNT_INTRP(I,J,1)=SNGL(TEMP(1)+TEMP(2))
	             MATRX_ELMNT_INTRP(I,J,2)=0.0
	             MATRX_ELMNT_INTRP(I,J,3)=0.0
	             MATRX_ELMNT_INTRP(I,J,4)=SNGL(TEMP(3)+TEMP(4))
	         END IF
			 			  
C----------END OF PROCEDURE IF 2 POINTS ARE DEFINED---------	         
			 
			  ELSE
C---------- PROCEDURE IF 1 POINTS IS DEFINED---------	
		 				
	          DO K=1,4
		       IF(MASKIN(I_INPUT(I,J,K),J_INPUT(I,J,K)).EQ.0) THEN
	             MATRX_ELMNT_INTRP(I,J,K)=1.0
	           ELSE
	             MATRX_ELMNT_INTRP(I,J,K)=0.0
	           END IF
	          END DO

C----------END OF PROCEDURE IF 2 POINTS ARE DEFINED---------				 
			  END IF
             END IF
	    END IF



	  ELSE
         DO K=1,4
          MATRX_ELMNT_INTRP(I,J,K)=0.0
          I_INPUT(I,J,K)=0
          J_INPUT(I,J,K)=0
	    COS_LAT=0.0
          SIN_LAT=0.0
          COS_LON=0.0
          SIN_LON=0.0
         END DO
	  END IF
      
      MATRX_ELMNT_INTRP(i,j,:)=min(MATRX_ELMNT_INTRP(i,j,:),1.0)
      MATRX_ELMNT_INTRP(i,j,:)=max(MATRX_ELMNT_INTRP(i,j,:),0.0)  
C--------REMORMING OF MATRIX ELEMENTS-------------------------------
500       SUM_MATR_ELMNT=MATRX_ELMNT_INTRP(I,J,1)
     &                  +MATRX_ELMNT_INTRP(I,J,2)
     &                  +MATRX_ELMNT_INTRP(I,J,3)
     &                  +MATRX_ELMNT_INTRP(I,J,4)

	  MATRX_ELMNT_INTRP(I,J,:)=
     &  MATRX_ELMNT_INTRP(I,J,:)/SUM_MATR_ELMNT


C--------DEFINITION OF ANGLES BETWEEN PARALLELS-----------------------
	  ROTVEC_COEFF(I,J,1)
     &               = SNGL (( COS_LAT*DCOS(DPIP180*DBLE(PHI_ROT))+
     &                         SIN_LAT*DSIN(DPIP180*DBLE(PHI_ROT)) *
     &                       ( COS_LON*DCOS(DPIP180*DBLE(LAMBDA_ROT))+
     &                         SIN_LON*DSIN(DPIP180*DBLE(LAMBDA_ROT))))
     &                                /DCOS(DPIP180*DBLE(YOUT(J))))

        ROTVEC_COEFF(I,J,2)
     &               = SNGL ((-DSIN(DPIP180*DBLE(PHI_ROT)) *
     &                       ( SIN_LON*DCOS(DPIP180*DBLE(LAMBDA_ROT))-
     &                         COS_LON*DSIN(DPIP180*DBLE(LAMBDA_ROT))))
     &                                /DCOS(DPIP180*DBLE(YOUT(J))))

	  ROTVEC_COEFF(I,J,3)=-ROTVEC_COEFF(I,J,2)
        ROTVEC_COEFF(I,J,4)= ROTVEC_COEFF(I,J,1)
C--------_RENORMING OF ANGLE COEFFICIENTS-------------------------

	 SUM_ROTVEC_COEFF=SQRT(ROTVEC_COEFF(I,J,1)*ROTVEC_COEFF(I,J,4)-
     &                       ROTVEC_COEFF(I,J,2)*ROTVEC_COEFF(I,J,3))

	 IF(SUM_ROTVEC_COEFF.NE.0.0)
     &        ROTVEC_COEFF(I,J,:)=ROTVEC_COEFF(I,J,:)/SUM_ROTVEC_COEFF
501    CONTINUE     	  	  
	 END DO
	END DO
		
	DEALLOCATE (TEMP,YINP,XINP)
   
      RETURN

1941  WRITE(*,*) 'ENTIRE GRID UNDEFINED!!!'
      STOP
	
	END
C============================================================
      SUBROUTINE WEIGHT_MATRIX_INTRP_VEC_SPECIAL(
     &     XIN,            !ARRAY OF X-GRID VALUES (INPUT) 
     &     YIN,            !ARRAY OF Y-GRID VALUES (INPUT)
     &    NXIN,            !NUMBER OF X-GRID POINTS(INPUT)
     &    NYIN,            !NUMBER OF Y-GRID POINTS(INPUT)
     &    XOUT,            !ARRAY OF X-GRID VALUES (OUTPUT)
     &    YOUT,            !ARRAY OF Y-GRID VALUES (OUTPUT)
     &   NXOUT,            !NUMBER OF X-GRID POINTS(OUTPUT)
     &   NYOUT,            !NUMBER OF Y-GRID POINTS(OUTPUT)
     &   MASKIN,           !INPUT SEA-LAND MASK
     &   MASKOUT,          !OUTPUT SEA-LAND MASK
     & I_INPUT,            !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & J_INPUT,            !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & MATRX_ELMNT_INTRP,  !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     & ROTVEC_COEFF,       !COS AND SIN OF ANGLES BETWEEN PARALLELS
     &   X_POLE,           !LON OF REAL NORTH POLE IN SPEC. SYSTEM
     &   Y_POLE,           !LAT OF REAL NORTH POLE IN SPEC. SYSTEM
     &   P_POLE,           !LON OF NEW NORT POLE IN GEO SYSTEM
     &   Q_POLE,           !LAT OF NEW NORT POLE IN GEO SYSTEM
     & INDPER,             !INDEX OF PERIODICITY:=0 -NONPERIODIC,=1 -PERIODIC CASE
     & FILLMISS,           !FILLING MISSED VALUES (0-NO, 1-YES)
     &         MMM_IN,     !FIRST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &          MM_IN,     ! LAST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &         NNN_IN,     !FIRST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &          NN_IN,     ! LAST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &         MMM_OUT,    !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &          MM_OUT,    ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &         NNN_OUT,    !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &          NN_OUT)    ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)	
     	
CCCCC  DEFINITION OF DATA PARAMETERS
      IMPLICIT NONE

	INCLUDE '0CRDFNC.INC'

	INTEGER INDPER !INDEX OF PERIODICITY:=0 -NONPERIODIC,=1 -PERIODIC CASE
	
	INTEGER NXIN,NYIN,NXOUT,NYOUT, FILLMISS

	INTEGER MASKIN(NXIN,NYIN)
      REAL(4) MASKOUT(NXOUT,NYOUT)

	INTEGER I_INPUT(NXOUT,NYOUT,4), !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &        J_INPUT(NXOUT,NYOUT,4)  !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID

	REAL(4) MATRX_ELMNT_INTRP(NXOUT,NYOUT,4)

	REAL(4) ROTVEC_COEFF(NXOUT,NYOUT,4)

	REAL(4) SUM_MATR_ELMNT,SUM_ROTVEC_COEFF

	REAL(4) XIN(NXIN), YIN(NYIN)                	!INPUT GRID

	REAL(4) XOUT(NXOUT), YOUT(NYOUT)            	!OUTPUT GRID
	
	REAL(4) X_POLE,Y_POLE,P_POLE,Q_POLE           	!PARAMETERS OF ROTATION

	REAL(8) DELTA_LEFT,DELTA_RIGHT

	REAL(8) RET_LON,RET_LAT,SIN_LON,COS_LON,SIN_LAT,COS_LAT	                    	!REVERSE ROTATION

      REAL(8) A,B,S,T,A0,B0,S0,T0,C1                  !AUXILARY VARIABLES
	
	REAL(8) DX_DA,DX_DB,DY_DA,DY_DB,
     &        DA_DS,DA_DT,DB_DS,DB_DT,
     &        DS_DP,DS_DQ,DT_DP,DT_DQ,

     &        DA_DP,DA_DQ,DB_DP,DB_DQ,
     &        DX_DP,DX_DQ,DY_DP,DY_DQ,
     &        DET, HP_DIVIDE_R,HQ_DIVIDE_R



	INTEGER I_NES,J_NES                             !AUXILARY INDEXES
     
	INTEGER I_LEFT,I_RIGHT,J_DOWN,J_UP              !AUXILARY INDEXES

	INTEGER I,J,K,M,N

	REAL(8) LAT_EXTR,COSLAT_EXTR,SINLAT_EXTR

	REAL(8) BILIN_DENOM

	REAL(8) X_LEFT,X_RIGHT,Y_DOWN,Y_UP

      REAL(8), ALLOCATABLE:: XINP(:),YINP(:), !RECALCULATED GRID FOR PERIODIC CASE
     &                       TEMP(:)
      REAL(8),ALLOCATABLE::DF(:,:), DFM1(:,:)
      
      INTEGER MMM_IN,  MM_IN,  NNN_IN,  NN_IN, 
     &        MMM_OUT, MM_OUT, NNN_OUT, NN_OUT	

      REAL    PIP180
      REAL(8) DPIP180              !FOR DEGREES TO RADIANS CONVERS
      PARAMETER(PIP180=3.141592653/180.0,
     &         DPIP180=3.1415926535897/180.0D00)

      LAT_EXTR = 89.9999

	COSLAT_EXTR = DCOS(DPIP180*LAT_EXTR)

	SINLAT_EXTR = DSIN(DPIP180*LAT_EXTR)

C---------INPUT GRID ANALYSIS ON PERIODICITY----------------------

      IF(INDPER.NE.1.AND.INDPER.NE.0) THEN
	   WRITE (*,*) 
     &'WRONG INDEX OF PERIODICITY IN SUBROUTINE WEIGHT_MATRIX_INTRP'
	   STOP 
	ENDIF
	
		ALLOCATE (XINP(NXIN+INDPER),YINP(NYIN),TEMP(4))
	    ALLOCATE(DF(2,2), DFM1(2,2))

C NEW LON AND LAT GRID DEFINITION

	     XINP(MMM_IN:MM_IN)=DBLE(XIN(MMM_IN:MM_IN))
           IF(INDPER.EQ.1) XINP(MM_IN+1)=DBLE(XIN(MMM_IN))+360D0 !COMPLETING OF LONGITUDE
	     	     
		 YINP=DBLE(YIN)

C		 YINP(:)=DMIN1(YINP(:), LAT_EXTR)
C	     YINP(:)=DMAX1(YINP(:),-LAT_EXTR)
C		 YINP(:)=DMIN1(YINP(:), LAT_EXTR)
C	     YINP(:)=DMAX1(YINP(:),-LAT_EXTR)
	     
C		 Y_POLE=DMIN1(Y_POLE, LAT_EXTR)
C	     Y_POLE=DMAX1(Y_POLE,-LAT_EXTR)
C	     Q_POLE=DMIN1(Y_POLE, LAT_EXTR)
C	     Q_POLE=DMAX1(Y_POLE,-LAT_EXTR)


      S0 = 2.0*DTAN((45.0 + DBLE(Y_POLE)/2.0)*DPIP180)
     &        *DCOS(DBLE(X_POLE)*DPIP180)

      T0 = 2.0*DTAN((45.0 + DBLE(Y_POLE)/2.0)*DPIP180)
     &        *DSIN(DBLE(X_POLE)*DPIP180)

      A0 = 2.0*DTAN((45.0 + DBLE(Q_POLE)/2.0)*DPIP180)
     &        *DCOS(DBLE(P_POLE)*DPIP180)

      B0 = 2.0*DTAN((45.0 + DBLE(Q_POLE)/2.0)*DPIP180)
     &        *DSIN(DBLE(P_POLE)*DPIP180)


CCCCCC INTERPOLATION FROM INPUT TO OUTPUT GRID
	DO J=NNN_OUT,NN_OUT
	 DO I=MMM_OUT,MM_OUT
          
          YOUT(J)=MIN(YOUT(J), SNGL(LAT_EXTR))
	    YOUT(J)=MAX(YOUT(J),-SNGL(LAT_EXTR))	 
	         
	  IF (MASKOUT(I,J).GT.0.5) THEN

	   	   !TRASFORMATION FROM NEW TO OLD GRID
      S = 2.0*DTAN((45.0 + DBLE(YOUT(J))/2.0)*DPIP180)
     &       *DCOS(DBLE(XOUT(I))*DPIP180)

      T = 2.0*DTAN((45.0 + DBLE(YOUT(J))/2.0)*DPIP180)
     &       *DSIN(DBLE(XOUT(I))*DPIP180)

	A = ((S*S0-T*T0)*(S-A0) + (T*S0+S*T0)*(T-B0)) / 
     &              ((S - A0)**2 + (T - B0)**2)
	B = ((T*S0+S*T0)*(S-A0) - (S*S0-T*T0)*(T-B0)) / 
     &              ((S - A0)**2 + (T - B0)**2)

	C1 = 0
	IF (A.LT.0) C1 = 180.0
	IF (B.LE.0) C1 = -C1

C         NESSESARY LONGITUDE

      COS_LON=A/DSQRT(A**2+B**2)
	SIN_LON=B/DSQRT(A**2+B**2)

	    SIN_LON=DMIN1(SIN_LON, 1.0D0)
	    SIN_LON=DMAX1(SIN_LON,-1.0D0)
	    COS_LON=DMIN1(COS_LON, 1.0D0)
	    COS_LON=DMAX1(COS_LON,-1.0D0)

          RET_LON=DSIGN(DACOS(COS_LON)/DPIP180,SIN_LON)

C         NESSESARY LATITUDE
      SIN_LAT=(A**2+B**2-4.0)/(A**2+B**2+4.0)
	SIN_LAT=DMIN1(SIN_LAT, SINLAT_EXTR)
	SIN_LAT=DMAX1(SIN_LAT,-SINLAT_EXTR)

	cos_lat=dsqrt(1.0-sin_lat**2)

	RET_LAT=DASIN(SIN_LAT)/DPIP180

	RET_LAT = DMIN1(RET_LAT, LAT_EXTR)
	RET_LAT = DMAX1(RET_LAT,-LAT_EXTR)

C         DIFFERENTIAL OF TRANSFORMATION

	DX_DA = -B / (A**2 + B**2)
	DX_DB =  A / (A**2 + B**2)

	DY_DA = A / ( DSQRT(A**2 + B**2) * (1.0+ (A**2 + B**2)/4.0))
	DY_DB = B / ( DSQRT(A**2 + B**2) * (1.0+ (A**2 + B**2)/4.0))

	DA_DS = (S0*(S-A0) + S*S0 - T*T0 + T0*(T-B0)) / 
     &           ( (S-A0)**2 + (T-B0)**2 ) -
     &	2.0*( (S*S0 - T*T0)*(S - A0) + (T*S0 + S*T0)*(T - B0) ) * 
     &        (S -A0) / ( (S-A0)**2 + (T-B0)**2 )**2

	DA_DT = (-T0*(S-A0) + S0*(T-B0) + T*S0 + S*T0) /
     &            ( (S-A0)**2 + (T-B0)**2 ) -
     &	2.0*( (S*S0 - T*T0)*(S - A0) + (T*S0 + S*T0)*(T - B0) ) * 
     &        (T - B0) / ( (S-A0)**2 + (T-B0)**2 )**2

	DB_DS = (T0*(S-A0) + T*S0 + S*T0 - S0*(T-B0)) /
     &              ( (S-A0)**2 + (T-B0)**2 ) -
     &        2.0*( (T*S0 + S*T0)*(S-A0) - (S*S0 - T*T0)*(T-B0))*(S-A0)/
     &             ( (S-A0)**2 + (T-B0)**2 )**2
	DB_DT = (S0*(S-A0) + T0*(T-B0) - S*S0 + T*T0) /
     &              ( (S-A0)**2 + (T-B0)**2 ) - 
     &        2.0*( (T*S0 + S*T0)*(S-A0) - (S*S0 - T*T0)*(T-B0))*(T-B0)/
     &             ( (S-A0)**2 + (T-B0)**2 )**2


      DS_DP = -2.0*DTAN((45.0 + DBLE(YOUT(J))/2.0)*DPIP180)
     &            *DSIN(DBLE(XOUT(I))*DPIP180)

      DS_DQ = DCOS(DBLE(XOUT(I))*DPIP180)
     &      /(DCOS((45.0 + DBLE(YOUT(J))/2.0)*DPIP180))**2

      DT_DP = 2.0*DTAN((45.0 + DBLE(YOUT(J))/2.0)*DPIP180)
     /           *DCOS(DBLE(XOUT(I))*DPIP180)

      DT_DQ = DSIN(DBLE(XOUT(I))*DPIP180) 
     &      /(DCOS((45.0 + DBLE(YOUT(J))/2.0)*DPIP180))**2

	DA_DP = DA_DS*DS_DP + DA_DT*DT_DP
	DA_DQ = DA_DS*DS_DQ + DA_DT*DT_DQ
	DB_DP = DB_DS*DS_DP + DB_DT*DT_DP
	DB_DQ = DB_DS*DS_DQ + DB_DT*DT_DQ
	
	DX_DP = DX_DA*DA_dP + DX_DB*DB_DP
	DX_DQ = DX_DA*DA_dQ + DX_DB*DB_DQ
	DY_DP = DY_DA*DA_dP + DY_DB*DB_DP
	DY_DQ = DY_DA*DA_dQ + DY_DB*DB_DQ

	DFM1(1,1)=DX_DP   !*DCOS(RET_LAT*DPIP180)
	DFM1(1,2)=DX_DQ   !*DCOS(RET_LAT*DPIP180)
	DFM1(2,1)=DY_DP
	DFM1(2,2)=DY_DQ


	DET=DFM1(2,2)*DFM1(1,1)-DFM1(1,2)*DFM1(2,1)

	DF(1,1)= DFM1(2,2)/DET
	DF(1,2)=-DFM1(1,2)/DET
	DF(2,1)=-DFM1(2,1)/DET
	DF(2,2)= DFM1(1,1)/DET

	HP_DIVIDE_R = DSQRT((DX_DP*DCOS(RET_LAT*DPIP180))**2 + (DY_DP)**2)
	HQ_DIVIDE_R = DSQRT((DX_DQ*DCOS(RET_LAT*DPIP180))**2 + (DY_DQ)**2)

	  ROTVEC_COEFF(I,J,1)=SNGL(DF(1,1)*HP_DIVIDE_R/cos_lat) 
        ROTVEC_COEFF(I,J,2)=SNGL(DF(1,2)*HP_DIVIDE_R) 
	  ROTVEC_COEFF(I,J,3)=SNGL(DF(2,1)*HQ_DIVIDE_R/cos_lat) 
        ROTVEC_COEFF(I,J,4)=SNGL(DF(2,2)*HQ_DIVIDE_R) 


C          CORRECTIONS

            IF(INDPER.EQ.1) THEN
	        IF(RET_LON .GT. XINP(MM_IN+1)) RET_LON=RET_LON-360D0
	        IF(RET_LON .LT. XINP(MMM_IN) ) RET_LON=RET_LON+360D0
            ELSE
              
              IF(RET_LON .GT. XINP(MM_IN)) THEN
	         DELTA_RIGHT=RET_LON-XINP(MM_IN)
	         RET_LON=RET_LON-360D0
               DELTA_LEFT=XIN(MMM_IN)-RET_LON
	         IF(DELTA_LEFT .GT. DELTA_RIGHT) RET_LON=RET_LON+360D0
	         GO TO 111
	        END IF

              IF(RET_LON .LT. XINP(MMM_IN)) THEN
	         DELTA_LEFT=XINP(MMM_IN)-RET_LON
	         RET_LON=RET_LON+360D0
 	         DELTA_RIGHT=RET_LON-XINP(MM_IN)
	         IF(DELTA_RIGHT .GT. DELTA_LEFT) RET_LON=RET_LON-360D0
	         GO TO 111
	        END IF
               	       
            END IF

111	 CONTINUE
C       IDENTIFICATION OF REVERSLY ROTATED POINT ON GEOGRAFIC GRID  
      
        I_NES=MMM_IN
	 
	   N=MM_IN+INDPER

1000     M=(I_NES+N)/2	 
	     
           IF (RET_LON.LT.XINP(M)) N=M
	     IF (RET_LON.GE.XINP(M)) I_NES=M
	     IF (N.GT.I_NES+1) GOTO 1000
	 
         I_LEFT =I_NES
	   I_RIGHT=I_NES+1
         IF((MM_IN-MMM_IN+1).EQ.1)I_RIGHT=I_NES

	   J_NES=NNN_IN
	   N=NN_IN
1001     M=(J_NES+N)/2	 
	     
           IF (RET_LAT.LT.YINP(M)) N=M
	     IF (RET_LAT.GE.YINP(M)) J_NES=M
	     IF (N.GT.J_NES+1) GOTO 1001
        
	   J_DOWN = J_NES
         J_UP   = J_NES+1
         IF((NN_IN-NNN_IN+1).EQ.1)J_UP=J_NES

C       MAIN BILINEAR INTERPOLATION

C--------------DEFINITION OF OUTPUT I-INDEXES AND PREPARING OF MATRIX CALCULATING----

1982     IF((I_LEFT .LT.MMM_IN)   .AND.(INDPER.EQ.1)) THEN
          
          I_INPUT(I,J,1)= I_LEFT + (MM_IN-MMM_IN+1)
	    I_INPUT(I,J,3)= I_LEFT + (MM_IN-MMM_IN+1)

	    X_LEFT = XINP(I_INPUT(I,J,1))-360D0

         ELSE
          
	    I_INPUT(I,J,1)=I_LEFT
          I_INPUT(I,J,3)=I_LEFT

          X_LEFT =XINP(I_INPUT(I,J,1))

	   END IF
	            
	   
	   IF((I_RIGHT.GT.MM_IN).AND.(INDPER.EQ.1)) THEN
          
		I_INPUT(I,J,2)=I_RIGHT-(MM_IN-MMM_IN+1)
		I_INPUT(I,J,4)=I_RIGHT-(MM_IN-MMM_IN+1)

		X_RIGHT=XINP(I_INPUT(I,J,2))+360D0
	   
	   ELSE
          
		I_INPUT(I,J,2)=I_RIGHT
		I_INPUT(I,J,4)=I_RIGHT

          X_RIGHT=XINP(I_INPUT(I,J,2))
	   
	   END IF


C--------------DEFINITION OF OUTPUT J-INDEXES--------------
	   J_INPUT(I,J,1)=J_DOWN
	   J_INPUT(I,J,2)=J_DOWN
	   J_INPUT(I,J,3)=J_UP
	   J_INPUT(I,J,4)=J_UP

	   Y_DOWN =YINP(J_INPUT(I,J,1))
	   Y_UP   =YINP(J_INPUT(I,J,3))

C---------IF ALL 4 POINTS ARE UNDEFINED MOVING BOUNDS OF RECTANGLE	   
	   IF((MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1))*
     &       MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2))*
     &       MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3))*
     &       MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4))).NE.0) THEN

           IF(FILLMISS.EQ.0) THEN
           MATRX_ELMNT_INTRP(I,J,1:4)=0.25
	     GO TO 501
	     END IF

           IF (INDPER.EQ.0) THEN

              IF ((I_LEFT.EQ.MMM_IN).AND.(I_RIGHT.EQ.MM_IN).AND.
     &            (J_DOWN.EQ.NNN_IN).AND.(J_UP   .EQ.NN_IN)) GO TO 1941

	        IF ((I_LEFT.EQ.MMM_IN).AND.(I_RIGHT.EQ.MM_IN)) THEN
	          IF (J_DOWN .GE.(NNN_IN+1)) J_DOWN=J_DOWN-1
	          IF (J_UP   .LE.( NN_IN-1)) J_UP  =J_UP  +1
	          I_LEFT =I_NES+1
	          I_RIGHT=I_NES
	        END IF

		  IF (I_LEFT .GE.(MMM_IN+1)) I_LEFT =I_LEFT -1
	        IF (I_RIGHT.LE.( MM_IN-1)) I_RIGHT=I_RIGHT+1
		 
		 ELSE
              
			IF (((I_RIGHT-I_LEFT).GE.(MM_IN-MMM_IN+1)).AND.
     &            (J_DOWN.EQ.NNN_IN).AND.(J_UP   .EQ.NN_IN)) GO TO 1941		 
		 				        
              IF((I_RIGHT-I_LEFT).GE.(MM_IN-MMM_IN+1)) THEN
	          IF (J_DOWN .GE.(NNN_IN+1)) J_DOWN=J_DOWN-1
	          IF (J_UP   .LE.( NN_IN-1)) J_UP  =J_UP  +1
	          I_LEFT =I_NES+1
	          I_RIGHT=I_NES
	        END IF  	        
			
              IF((I_RIGHT-I_LEFT).LT.(MM_IN-MMM_IN+1)) THEN
                  I_LEFT =I_LEFT -1
                  I_RIGHT=I_RIGHT+1
	        END IF

		 END IF
	     
		 GO TO 1982
	   
	   END IF
C---------END OF MOVING BOUNDS OF RECTANGLE--------------------------

	 
	   BILIN_DENOM= 1D0

	   IF (X_RIGHT .NE.X_LEFT) 
     &       BILIN_DENOM=BILIN_DENOM/
     &      (FNCLON(X_RIGHT)-FNCLON(X_LEFT))

	   IF (Y_UP    .NE.Y_DOWN)
     &       BILIN_DENOM=BILIN_DENOM/
     &      (FNCLAT(Y_UP)   -FNCLAT(Y_DOWN))
	 	 
	   TEMP=BILIN_DENOM


	    IF (X_RIGHT .NE.X_LEFT) THEN

           TEMP(1)= TEMP(1)*(FNCLON(X_RIGHT) - FNCLON(RET_LON))
     
           TEMP(2)= TEMP(2)*(FNCLON(RET_LON) - FNCLON(X_LEFT) )
		 	 
	     TEMP(3)= TEMP(3)*(FNCLON(X_RIGHT) - FNCLON(RET_LON)) 
     
	     TEMP(4)= TEMP(4)*(FNCLON(RET_LON) - FNCLON(X_LEFT) )

          END IF


		IF (Y_UP    .NE.Y_DOWN) THEN

           TEMP(1)= TEMP(1)*(FNCLAT(Y_UP)    - FNCLAT(RET_LAT))
     
           TEMP(2)= TEMP(2)*(FNCLAT(Y_UP)    - FNCLAT(RET_LAT))
		 	 
	     TEMP(3)= TEMP(3)*(FNCLAT(RET_LAT) - FNCLAT(Y_DOWN) ) 
     
	     TEMP(4)= TEMP(4)*(FNCLAT(RET_LAT) - FNCLAT(Y_DOWN) )

          END IF


C---------- PROCEDURE IF 4 POINTS ARE DEFINED---------	  
	    IF((MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1))+
     &        MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2))+
     &        MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3))+
     &        MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4))).EQ.0) THEN
	     	
			DO K=1,4
		     MATRX_ELMNT_INTRP(I,J,K)=SNGL(TEMP(K))
	        END DO
C----------END OF PROCEDURE IF 4 POINTS ARE DEFINED---------

	    ELSE
C---------- PROCEDURE IF 3 POINTS ARE DEFINED---------
	       IF((MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1))+
     &           MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2))+
     &           MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3))+
     &           MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4))).EQ.1) THEN


	         !THE 1-ST POINT IS UNDEFINED
		     IF(MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1)).EQ.1) THEN
	            MATRX_ELMNT_INTRP(I,J,1)=0.0
	            MATRX_ELMNT_INTRP(I,J,2)=SNGL(TEMP(2)+TEMP(1))
	            MATRX_ELMNT_INTRP(I,J,3)=SNGL(TEMP(3)+TEMP(1))
	            MATRX_ELMNT_INTRP(I,J,4)=SNGL(TEMP(4)-TEMP(1))
               END IF
	 
	         !THE 2-ND POINT IS UNDEFINED
	         IF(MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2)).EQ.1) THEN
	            MATRX_ELMNT_INTRP(I,J,1)=SNGL(TEMP(1)+TEMP(2))
	            MATRX_ELMNT_INTRP(I,J,2)=0.0
	            MATRX_ELMNT_INTRP(I,J,3)=SNGL(TEMP(3)-TEMP(2))
	            MATRX_ELMNT_INTRP(I,J,4)=SNGL(TEMP(4)+TEMP(2))
	         END IF
	
	         !THE 3-RD POINT IS UNDEFINED
	         IF(MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3)).EQ.1) THEN
	            MATRX_ELMNT_INTRP(I,J,1)=SNGL(TEMP(1)+TEMP(3))
	            MATRX_ELMNT_INTRP(I,J,2)=SNGL(TEMP(2)-TEMP(3))
	            MATRX_ELMNT_INTRP(I,J,3)=0.0
	            MATRX_ELMNT_INTRP(I,J,4)=SNGL(TEMP(4)+TEMP(3))
			 END IF

	         !THE 4-TH POINT IS UNDEFINED	       
		     IF(MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4)).EQ.1) THEN
	            MATRX_ELMNT_INTRP(I,J,1)=SNGL(TEMP(1)-TEMP(4))
	            MATRX_ELMNT_INTRP(I,J,2)=SNGL(TEMP(2)+TEMP(4))
	            MATRX_ELMNT_INTRP(I,J,3)=SNGL(TEMP(3)+TEMP(4))
	            MATRX_ELMNT_INTRP(I,J,4)=0.0
		     END IF 
C----------END OF PROCEDURE IF 3 POINTS ARE DEFINED---------
		 
		   ELSE
C---------- PROCEDURE IF 2 POINTS ARE DEFINED---------
	          IF((MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1))+
     &              MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2))+
     &              MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3))+
     &              MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4))).EQ.2) THEN
	
	         !THE 1-ST AND THE 2-ND POINTS ARE UNDEFINED		   
		     IF((MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1)).EQ.1).AND.
     &            (MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2)).EQ.1)) THEN
	             MATRX_ELMNT_INTRP(I,J,1)=0.0
	             MATRX_ELMNT_INTRP(I,J,2)=0.0
	             MATRX_ELMNT_INTRP(I,J,3)=SNGL(TEMP(1)+TEMP(3))
	             MATRX_ELMNT_INTRP(I,J,4)=SNGL(TEMP(2)+TEMP(4))
	         END IF

	         !THE 1-ST AND THE 3-RD POINTS ARE UNDEFINED
		     IF((MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1)).EQ.1).AND.
     &            (MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3)).EQ.1)) THEN
	             MATRX_ELMNT_INTRP(I,J,1)=0.0
	             MATRX_ELMNT_INTRP(I,J,2)=SNGL(TEMP(1)+TEMP(2))
	             MATRX_ELMNT_INTRP(I,J,3)=0.0
	             MATRX_ELMNT_INTRP(I,J,4)=SNGL(TEMP(3)+TEMP(4))
	         END IF

	         !THE 3-RD AND THE 4-TH POINTS ARE UNDEFINED		   
		     IF((MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3)).EQ.1).AND.
     &            (MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4)).EQ.1)) THEN
	             MATRX_ELMNT_INTRP(I,J,1)=SNGL(TEMP(1)+TEMP(3))
	             MATRX_ELMNT_INTRP(I,J,2)=SNGL(TEMP(2)+TEMP(4))
	             MATRX_ELMNT_INTRP(I,J,3)=0.0
	             MATRX_ELMNT_INTRP(I,J,4)=0.0
	         END IF

	         !THE 4-TH AND THE 2-ND POINTS ARE UNDEFINED
		     IF((MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4)).EQ.1).AND.
     &            (MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2)).EQ.1)) THEN
	             MATRX_ELMNT_INTRP(I,J,1)=SNGL(TEMP(1)+TEMP(2))
	             MATRX_ELMNT_INTRP(I,J,2)=0.0
	             MATRX_ELMNT_INTRP(I,J,3)=SNGL(TEMP(3)+TEMP(4))
	             MATRX_ELMNT_INTRP(I,J,4)=0.0
	         END IF

	         !THE 1-ST AND THE 4-TH POINTS ARE UNDEFINED
		     IF((MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1)).EQ.1).AND.
     &            (MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4)).EQ.1)) THEN
	             MATRX_ELMNT_INTRP(I,J,1)=0.0
	             MATRX_ELMNT_INTRP(I,J,2)=SNGL(TEMP(1)+TEMP(2))
	             MATRX_ELMNT_INTRP(I,J,3)=SNGL(TEMP(3)+TEMP(4))
	             MATRX_ELMNT_INTRP(I,J,4)=0.0
	         END IF

	         !THE 2-ND AND THE 3-RD POINTS ARE UNDEFINED
		     IF((MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3)).EQ.1).AND.
     &            (MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2)).EQ.1)) THEN
                   MATRX_ELMNT_INTRP(I,J,1)=SNGL(TEMP(1)+TEMP(2))
	             MATRX_ELMNT_INTRP(I,J,2)=0.0
	             MATRX_ELMNT_INTRP(I,J,3)=0.0
	             MATRX_ELMNT_INTRP(I,J,4)=SNGL(TEMP(3)+TEMP(4))
	         END IF

C----------END OF PROCEDURE IF 2 POINTS ARE DEFINED---------	         
			 
			  ELSE
C---------- PROCEDURE IF 1 POINTS IS DEFINED---------	
		 				
	          DO K=1,4
		       IF(MASKIN(I_INPUT(I,J,K),J_INPUT(I,J,K)).EQ.0) THEN
	             MATRX_ELMNT_INTRP(I,J,K)=1.0
	           ELSE
	             MATRX_ELMNT_INTRP(I,J,K)=0.0
	           END IF
	          END DO

C----------END OF PROCEDURE IF 2 POINTS ARE DEFINED---------				 
			  END IF
             END IF
	    END IF

	  ELSE
         DO K=1,4
          MATRX_ELMNT_INTRP(I,J,K)=0.0
          I_INPUT(I,J,K)=0
          J_INPUT(I,J,K)=0
	   END DO
	  END IF

      MATRX_ELMNT_INTRP(i,j,:)=min(MATRX_ELMNT_INTRP(i,j,:),1.0)
      MATRX_ELMNT_INTRP(i,j,:)=max(MATRX_ELMNT_INTRP(i,j,:),0.0)  

C--------REMORMING OF MATRIX ELEMENTS-------------------------------
500       SUM_MATR_ELMNT=MATRX_ELMNT_INTRP(I,J,1)
     &                  +MATRX_ELMNT_INTRP(I,J,2)
     &                  +MATRX_ELMNT_INTRP(I,J,3)
     &                  +MATRX_ELMNT_INTRP(I,J,4)

	  MATRX_ELMNT_INTRP(I,J,:)=
     &  MATRX_ELMNT_INTRP(I,J,:)/SUM_MATR_ELMNT

	 SUM_ROTVEC_COEFF=SQRT(ROTVEC_COEFF(I,J,1)*ROTVEC_COEFF(I,J,4)-
     &                       ROTVEC_COEFF(I,J,2)*ROTVEC_COEFF(I,J,3))

	 IF(SUM_ROTVEC_COEFF.NE.0.0)
     &        ROTVEC_COEFF(I,J,:)=ROTVEC_COEFF(I,J,:)/SUM_ROTVEC_COEFF
                 
501      CONTINUE
     	  	  
	 END DO
	END DO

	DEALLOCATE (DFM1,DF,TEMP,YINP,XINP)

      RETURN

1941  WRITE(*,*) 'ENTIRE GRID UNDEFINED!!!'
      STOP
	
	END
C=========================================================
      SUBROUTINE WEIGHT_MATRIX_INTRP_VEC_SPECIAL_2(
     &     XIN,            !ARRAY OF X-GRID VALUES (INPUT) 
     &     YIN,            !ARRAY OF Y-GRID VALUES (INPUT)
     &    NXIN,            !NUMBER OF X-GRID POINTS(INPUT)
     &    NYIN,            !NUMBER OF Y-GRID POINTS(INPUT)
     &    XOUT,            !ARRAY OF X-GRID VALUES (OUTPUT)
     &    YOUT,            !ARRAY OF Y-GRID VALUES (OUTPUT)
     &   NXOUT,            !NUMBER OF X-GRID POINTS(OUTPUT)
     &   NYOUT,            !NUMBER OF Y-GRID POINTS(OUTPUT)
     &   MASKIN,           !INPUT SEA-LAND MASK
     &   MASKOUT,          !OUTPUT SEA-LAND MASK
     & I_INPUT,            !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & J_INPUT,            !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     & MATRX_ELMNT_INTRP,  !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     & ROTVEC_COEFF,       !COS AND SIN OF ANGLES BETWEEN PARALLELS
     &   X_POLE,           !LON OF NEW NORTH POLE IN GEO. SYSTEM
     &   Y_POLE,           !LAT OF NEW NORTH POLE IN GEO. SYSTEM
     &  L0_POLE,           !LON OF X_POLE MERIDIAN IN NEW SYSTEM
     & INDPER,             !INDEX OF PERIODICITY:=0 -NONPERIODIC,=1 -PERIODIC CASE
     & FILLMISS,           !FILLING MISSED VALUES (0-NO, 1-YES)
     &         MMM_IN,     !FIRST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &          MM_IN,     ! LAST SIGNIFICANT POINT IN X-DIRECTION (INPUT)
     &         NNN_IN,     !FIRST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &          NN_IN,     ! LAST SIGNIFICANT POINT IN Y-DIRECTION (INPUT)
     &         MMM_OUT,    !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &          MM_OUT,    ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &         NNN_OUT,    !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &          NN_OUT)    ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)	
     	
CCCCC  DEFINITION OF DATA PARAMETERS
      IMPLICIT NONE

	INCLUDE '0CRDFNC.INC'

	INTEGER INDPER !INDEX OF PERIODICITY:=0 -NONPERIODIC,=1 -PERIODIC CASE
	
	INTEGER NXIN,NYIN,NXOUT,NYOUT, FILLMISS

	INTEGER MASKIN(NXIN,NYIN)
      REAL(4) MASKOUT(NXOUT,NYOUT)

	INTEGER I_INPUT(NXOUT,NYOUT,4), !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &        J_INPUT(NXOUT,NYOUT,4)  !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID

	REAL(4) MATRX_ELMNT_INTRP(NXOUT,NYOUT,4)

	REAL(4) ROTVEC_COEFF(NXOUT,NYOUT,4)

	REAL(4) SUM_MATR_ELMNT,SUM_ROTVEC_COEFF

	REAL(4) XIN(NXIN), YIN(NYIN)                	!INPUT GRID

	REAL(4) XOUT(NXOUT),YOUT(NYOUT) !OUTPUT GRID
	
	REAL(4) X_POLE,Y_POLE,L0_POLE                    !PARAMETERS OF ROTATION

	REAL(8) DELTA_LEFT,DELTA_RIGHT

	REAL(8) RET_LON,RET_LAT,SIN_LON,COS_LON,SIN_LAT,COS_LAT	                    	!REVERSE ROTATION

      REAL(8) A,B,S,T,A_BIG                           !AUXILARY VARIABLES 
	
	REAL(8) DS_DA,DS_DB,DT_DA,DT_DB,
     &        DX_DS,DX_DT,DY_DS,DY_DT,
     &        DS_DP,DS_DQ,DT_DP,DT_DQ,

     &        DA_DP,DA_DQ,DB_DP,DB_DQ,
     &        DX_DP,DX_DQ,DY_DP,DY_DQ,
     &        DET, HP_DIVIDE_R,HQ_DIVIDE_R



	INTEGER I_NES,J_NES                              	!AUXILARY INDEXES
     
	INTEGER I_LEFT,I_RIGHT,J_DOWN,J_UP              !AUXILARY INDEXES

	INTEGER I,J,K,M,N

	REAL(8) LAT_EXTR,COSLAT_EXTR,SINLAT_EXTR

	REAL(8) BILIN_DENOM

	REAL(8) X_LEFT,X_RIGHT,Y_DOWN,Y_UP

      REAL(8), ALLOCATABLE:: XINP(:),YINP(:), !RECALCULATED GRID FOR PERIODIC CASE
     &                       TEMP(:)
      REAL(8),ALLOCATABLE::DF(:,:), DFM1(:,:)
      
      INTEGER MMM_IN,  MM_IN,  NNN_IN,  NN_IN, 
     &        MMM_OUT, MM_OUT, NNN_OUT, NN_OUT	

      REAL    PIP180
      REAL(8) DPIP180              !FOR DEGREES TO RADIANS CONVERS
      PARAMETER(PIP180=3.141592653/180.0,
     &         DPIP180=3.1415926535897/180.0D00)

      LAT_EXTR = 89.9999

	COSLAT_EXTR = DCOS(DPIP180*LAT_EXTR)

	SINLAT_EXTR = DSIN(DPIP180*LAT_EXTR)

C---------INPUT GRID ANALYSIS ON PERIODICITY----------------------

      IF(INDPER.NE.1.AND.INDPER.NE.0) THEN
	   WRITE (*,*) 
     &'WRONG INDEX OF PERIODICITY IN SUBROUTINE WEIGHT_MATRIX_INTRP'
	   STOP 
	ENDIF
	
		ALLOCATE (XINP(NXIN+INDPER),YINP(NYIN),TEMP(4))
	    ALLOCATE(DF(2,2), DFM1(2,2))

C NEW LON AND LAT GRID DEFINITION

	     XINP(MMM_IN:MM_IN)=DBLE(XIN(MMM_IN:MM_IN))
           IF(INDPER.EQ.1) XINP(MM_IN+1)=DBLE(XIN(MMM_IN))+360D0 !COMPLETING OF LONGITUDE
	     	     
		 YINP=DBLE(YIN)

C		 YINP(:)=DMIN1(YINP(:), LAT_EXTR)
C	     YINP(:)=DMAX1(YINP(:),-LAT_EXTR)
C		 YINP(:)=DMIN1(YINP(:), LAT_EXTR)
C	     YINP(:)=DMAX1(YINP(:),-LAT_EXTR)
	     
C		 Y_POLE=DMIN1(Y_POLE, LAT_EXTR)
C	     Y_POLE=DMAX1(Y_POLE,-LAT_EXTR)
C	     Q_POLE=DMIN1(Y_POLE, LAT_EXTR)
C	     Q_POLE=DMAX1(Y_POLE,-LAT_EXTR)


      A_BIG =  DTAN((45.0 + DBLE(Y_POLE)/2.0)*DPIP180)


CCCCCC INTERPOLATION FROM INPUT TO OUTPUT GRID
	DO J=NNN_OUT,NN_OUT
	 DO I=MMM_OUT,MM_OUT
          YOUT(J)=MIN(YOUT(J), SNGL(LAT_EXTR))
	    YOUT(J)=MAX(YOUT(J),-SNGL(LAT_EXTR))	 
        
	  IF (MASKOUT(I,J).GT.0.5) THEN

	   !TRASFORMATION FROM NEW TO OLD GRID
      A = DTAN((45.0 + DBLE(YOUT(J))/2.0)*DPIP180)
     &       *DCOS(DBLE(XOUT(I)-L0_POLE)*DPIP180)

      B = DTAN((45.0 + DBLE(YOUT(J))/2.0)*DPIP180)
     &       *DSIN(DBLE(XOUT(I)-L0_POLE)*DPIP180)

	S = ((A*A_BIG+1.0)*(A+A_BIG)+B**2*A_BIG) / 
     &              ((A+A_BIG)**2 + B**2)
	T = (B*A_BIG*(A+A_BIG)-B*(A*A_BIG+1.0))  / 
     &              ((A+A_BIG)**2 + B**2)


C         NESSESARY LONGITUDE

      COS_LON=S/DSQRT(S**2+T**2)
	SIN_LON=T/DSQRT(S**2+T**2)

	    SIN_LON=DMIN1(SIN_LON, 1.0D0)
	    SIN_LON=DMAX1(SIN_LON,-1.0D0)
	    COS_LON=DMIN1(COS_LON, 1.0D0)
	    COS_LON=DMAX1(COS_LON,-1.0D0)

          RET_LON=DSIGN(DACOS(COS_LON)/DPIP180,SIN_LON)+DBLE(X_POLE)

C         NESSESARY LATITUDE
      SIN_LAT=(S**2+T**2-1.0)/(S**2+T**2+1.0)
	SIN_LAT=DMIN1(SIN_LAT, SINLAT_EXTR)
	SIN_LAT=DMAX1(SIN_LAT,-SINLAT_EXTR)

	cos_lat=dsqrt(1.0-sin_lat**2)

	RET_LAT=DASIN(SIN_LAT)/DPIP180

	RET_LAT = DMIN1(RET_LAT, LAT_EXTR)
	RET_LAT = DMAX1(RET_LAT,-LAT_EXTR)

C         DIFFERENTIAL OF TRANSFORMATION

      DA_DP = -DTAN((45.0 + DBLE(YOUT(J))/2.0)*DPIP180)
     &            *DSIN(DBLE(XOUT(I)-L0_POLE)*DPIP180)

      DA_DQ = DCOS(DBLE(XOUT(I)-L0_POLE)*DPIP180)/2.0
     &      /(DCOS((45.0 + DBLE(YOUT(J))/2.0)*DPIP180))**2

      DB_DP =  DTAN((45.0 + DBLE(YOUT(J))/2.0)*DPIP180)
     /           *DCOS(DBLE(XOUT(I)-L0_POLE)*DPIP180)

      DB_DQ = DSIN(DBLE(XOUT(I)-L0_POLE)*DPIP180)/2.0 
     &      /(DCOS((45.0 + DBLE(YOUT(J))/2.0)*DPIP180))**2

      DS_DA=(1.0+A*A_BIG+A_BIG*(A+A_BIG))
     &     /((A+A_BIG)**2+B**2)
     &  -
     &      2.0*(A+A_BIG)*((A+A_BIG)*(1.0+A*A_BIG)+A_BIG*B**2)
     &     /((A+A_BIG)**2+B**2)**2

      
      DS_DB=2.0*A_BIG*B/((A+A_BIG)**2+B**2)
     &  -
     &      2.0*B*((A+A_BIG)*(1.0+A*A_BIG)+A_BIG*B**2)
     &     /((A+A_BIG)**2+B**2)**2
      
      
	DT_DA=-(2.0*(A+A_BIG)*(A_BIG*(A+A_BIG)*B
     &           -(1.0+A*A_BIG)*B))
     &     /((A+A_BIG)**2+B**2)**2

      
      DT_DB=(A_BIG*(A+A_BIG)-1.0-A*A_BIG)
     &     /((A+A_BIG)**2+B**2)
     &  -    2.0*B*(A_BIG*(A+A_BIG)*B-(1.0+A*A_BIG)*B)
     &     /((A+A_BIG)**2+B**2)**2

      
      DX_DS=-T/(S**2+T**2)
	DX_DT= S/(S**2+T**2)
	DY_DS=2.0*S/(DSQRT(S**2+T**2)*(1.0+S**2+T**2))
	DY_DT=2.0*T/(DSQRT(S**2+T**2)*(1.0+S**2+T**2))

      DS_DP=DS_DA*DA_DP+DS_DB*DB_DP
      DS_DQ=DS_DA*DA_DQ+DS_DB*DB_DQ
      DT_DP=DT_DA*DA_DP+DT_DB*DB_DP
      DT_DQ=DT_DA*DA_DQ+DT_DB*DB_DQ

	DX_DP=DX_DS*DS_DP+DX_DT*DT_DP
	DY_DP=DY_DS*DS_DP+DY_DT*DT_DP
	DX_DQ=DX_DS*DS_DQ+DX_DT*DT_DQ
	DY_DQ=DY_DS*DS_DQ+DY_DT*DT_DQ


	DFM1(1,1)=DX_DP   !*DCOS(RET_LAT*DPIP180)
	DFM1(1,2)=DX_DQ   !*DCOS(RET_LAT*DPIP180)
	DFM1(2,1)=DY_DP
	DFM1(2,2)=DY_DQ


	DET=DFM1(2,2)*DFM1(1,1)-DFM1(1,2)*DFM1(2,1)

	DF(1,1)= DFM1(2,2)/DET
	DF(1,2)=-DFM1(1,2)/DET
	DF(2,1)=-DFM1(2,1)/DET
	DF(2,2)= DFM1(1,1)/DET

	HP_DIVIDE_R = DSQRT((DX_DP*DCOS(RET_LAT*DPIP180))**2 + (DY_DP)**2)
	HQ_DIVIDE_R = DSQRT((DX_DQ*DCOS(RET_LAT*DPIP180))**2 + (DY_DQ)**2)

	  ROTVEC_COEFF(I,J,1)=SNGL(DF(1,1)*HP_DIVIDE_R/cos_lat) 
        ROTVEC_COEFF(I,J,2)=SNGL(DF(1,2)*HP_DIVIDE_R) 
	  ROTVEC_COEFF(I,J,3)=SNGL(DF(2,1)*HQ_DIVIDE_R/cos_lat) 
        ROTVEC_COEFF(I,J,4)=SNGL(DF(2,2)*HQ_DIVIDE_R) 


C          CORRECTIONS

            IF(INDPER.EQ.1) THEN
	        IF(RET_LON .GT. XINP(MM_IN+1)) RET_LON=RET_LON-360D0
	        IF(RET_LON .LT. XINP(MMM_IN) ) RET_LON=RET_LON+360D0
            ELSE
              
              IF(RET_LON .GT. XINP(MM_IN)) THEN
	         DELTA_RIGHT=RET_LON-XINP(MM_IN)
	         RET_LON=RET_LON-360D0
               DELTA_LEFT=XIN(MMM_IN)-RET_LON
	         IF(DELTA_LEFT .GT. DELTA_RIGHT) RET_LON=RET_LON+360D0
	         GO TO 111
	        END IF

              IF(RET_LON .LT. XINP(MMM_IN)) THEN
	         DELTA_LEFT=XINP(MMM_IN)-RET_LON
	         RET_LON=RET_LON+360D0
 	         DELTA_RIGHT=RET_LON-XINP(MM_IN)
	         IF(DELTA_RIGHT .GT. DELTA_LEFT) RET_LON=RET_LON-360D0
	         GO TO 111
	        END IF
               	       
            END IF

111	 CONTINUE
C       IDENTIFICATION OF REVERSLY ROTATED POINT ON GEOGRAFIC GRID  
      
        I_NES=MMM_IN
	 
	   N=MM_IN+INDPER

1000     M=(I_NES+N)/2	 
	     
           IF (RET_LON.LT.XINP(M)) N=M
	     IF (RET_LON.GE.XINP(M)) I_NES=M
	     IF (N.GT.I_NES+1) GOTO 1000
	 
         I_LEFT =I_NES
	   I_RIGHT=I_NES+1
         IF((MM_IN-MMM_IN+1).EQ.1)I_RIGHT=I_NES

	   J_NES=NNN_IN
	   N=NN_IN
1001     M=(J_NES+N)/2	 
	     
           IF (RET_LAT.LT.YINP(M)) N=M
	     IF (RET_LAT.GE.YINP(M)) J_NES=M
	     IF (N.GT.J_NES+1) GOTO 1001
        
	   J_DOWN = J_NES
         J_UP   = J_NES+1
         IF((NN_IN-NNN_IN+1).EQ.1)J_UP=J_NES

C       MAIN BILINEAR INTERPOLATION

C--------------DEFINITION OF OUTPUT I-INDEXES AND PREPARING OF MATRIX CALCULATING----

1982     IF((I_LEFT .LT.MMM_IN)   .AND.(INDPER.EQ.1)) THEN
          
          I_INPUT(I,J,1)= I_LEFT + (MM_IN-MMM_IN+1)
	    I_INPUT(I,J,3)= I_LEFT + (MM_IN-MMM_IN+1)

	    X_LEFT = XINP(I_INPUT(I,J,1))-360D0

         ELSE
          
	    I_INPUT(I,J,1)=I_LEFT
          I_INPUT(I,J,3)=I_LEFT

          X_LEFT =XINP(I_INPUT(I,J,1))

	   END IF
	            
	   
	   IF((I_RIGHT.GT.MM_IN).AND.(INDPER.EQ.1)) THEN
          
		I_INPUT(I,J,2)=I_RIGHT-(MM_IN-MMM_IN+1)
		I_INPUT(I,J,4)=I_RIGHT-(MM_IN-MMM_IN+1)

		X_RIGHT=XINP(I_INPUT(I,J,2))+360D0
	   
	   ELSE
          
		I_INPUT(I,J,2)=I_RIGHT
		I_INPUT(I,J,4)=I_RIGHT

          X_RIGHT=XINP(I_INPUT(I,J,2))
	   
	   END IF


C--------------DEFINITION OF OUTPUT J-INDEXES--------------
	   J_INPUT(I,J,1)=J_DOWN
	   J_INPUT(I,J,2)=J_DOWN
	   J_INPUT(I,J,3)=J_UP
	   J_INPUT(I,J,4)=J_UP

	   Y_DOWN =YINP(J_INPUT(I,J,1))
	   Y_UP   =YINP(J_INPUT(I,J,3))

C---------IF ALL 4 POINTS ARE UNDEFINED MOVING BOUNDS OF RECTANGLE	   
	   IF((MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1))*
     &       MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2))*
     &       MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3))*
     &       MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4))).NE.0) THEN

           IF(FILLMISS.EQ.0) THEN
           MATRX_ELMNT_INTRP(I,J,1:4)=0.25
            ROTVEC_COEFF(I,J,1)=1.0
            ROTVEC_COEFF(I,J,2)=0.0
            ROTVEC_COEFF(I,J,3)=0.0
            ROTVEC_COEFF(I,J,4)=1.0
	     GO TO 501
	     END IF

           IF (INDPER.EQ.0) THEN

              IF ((I_LEFT.EQ.MMM_IN).AND.(I_RIGHT.EQ.MM_IN).AND.
     &            (J_DOWN.EQ.NNN_IN).AND.(J_UP   .EQ.NN_IN)) GO TO 1941

	        IF ((I_LEFT.EQ.MMM_IN).AND.(I_RIGHT.EQ.MM_IN)) THEN
	          IF (J_DOWN .GE.(NNN_IN+1)) J_DOWN=J_DOWN-1
	          IF (J_UP   .LE.( NN_IN-1)) J_UP  =J_UP  +1
	          I_LEFT =I_NES+1
	          I_RIGHT=I_NES
	        END IF

		  IF (I_LEFT .GE.(MMM_IN+1)) I_LEFT =I_LEFT -1
	        IF (I_RIGHT.LE.( MM_IN-1)) I_RIGHT=I_RIGHT+1
		 
		 ELSE
              
			IF (((I_RIGHT-I_LEFT).GE.(MM_IN-MMM_IN+1)).AND.
     &            (J_DOWN.EQ.NNN_IN).AND.(J_UP   .EQ.NN_IN)) GO TO 1941		 
		 				        
              IF((I_RIGHT-I_LEFT).GE.(MM_IN-MMM_IN+1)) THEN
	          IF (J_DOWN .GE.(NNN_IN+1)) J_DOWN=J_DOWN-1
	          IF (J_UP   .LE.( NN_IN-1)) J_UP  =J_UP  +1
	          I_LEFT =I_NES+1
	          I_RIGHT=I_NES
	        END IF  	        
			
              IF((I_RIGHT-I_LEFT).LT.(MM_IN-MMM_IN+1)) THEN
                  I_LEFT =I_LEFT -1
                  I_RIGHT=I_RIGHT+1
	        END IF

		 END IF
	     
		 GO TO 1982
	   
	   END IF
C---------END OF MOVING BOUNDS OF RECTANGLE--------------------------

	 
	   BILIN_DENOM= 1D0

	   IF (X_RIGHT .NE.X_LEFT) 
     &       BILIN_DENOM=BILIN_DENOM/
     &      (FNCLON(X_RIGHT)-FNCLON(X_LEFT))

	   IF (Y_UP    .NE.Y_DOWN)
     &       BILIN_DENOM=BILIN_DENOM/
     &      (FNCLAT(Y_UP)   -FNCLAT(Y_DOWN))
	 	 
	   TEMP=BILIN_DENOM


	    IF (X_RIGHT .NE.X_LEFT) THEN

           TEMP(1)= TEMP(1)*(FNCLON(X_RIGHT) - FNCLON(RET_LON))
     
           TEMP(2)= TEMP(2)*(FNCLON(RET_LON) - FNCLON(X_LEFT) )
		 	 
	     TEMP(3)= TEMP(3)*(FNCLON(X_RIGHT) - FNCLON(RET_LON)) 
     
	     TEMP(4)= TEMP(4)*(FNCLON(RET_LON) - FNCLON(X_LEFT) )

          END IF


		IF (Y_UP    .NE.Y_DOWN) THEN

           TEMP(1)= TEMP(1)*(FNCLAT(Y_UP)    - FNCLAT(RET_LAT))
     
           TEMP(2)= TEMP(2)*(FNCLAT(Y_UP)    - FNCLAT(RET_LAT))
		 	 
	     TEMP(3)= TEMP(3)*(FNCLAT(RET_LAT) - FNCLAT(Y_DOWN) ) 
     
	     TEMP(4)= TEMP(4)*(FNCLAT(RET_LAT) - FNCLAT(Y_DOWN) )

          END IF


C---------- PROCEDURE IF 4 POINTS ARE DEFINED---------	  
	    IF((MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1))+
     &        MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2))+
     &        MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3))+
     &        MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4))).EQ.0) THEN
	     	
			DO K=1,4
		     MATRX_ELMNT_INTRP(I,J,K)=SNGL(TEMP(K))
	        END DO
C----------END OF PROCEDURE IF 4 POINTS ARE DEFINED---------

	    ELSE
C---------- PROCEDURE IF 3 POINTS ARE DEFINED---------
	       IF((MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1))+
     &           MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2))+
     &           MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3))+
     &           MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4))).EQ.1) THEN


	         !THE 1-ST POINT IS UNDEFINED
		     IF(MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1)).EQ.1) THEN
	            MATRX_ELMNT_INTRP(I,J,1)=0.0
	            MATRX_ELMNT_INTRP(I,J,2)=SNGL(TEMP(2)+TEMP(1))
	            MATRX_ELMNT_INTRP(I,J,3)=SNGL(TEMP(3)+TEMP(1))
	            MATRX_ELMNT_INTRP(I,J,4)=SNGL(TEMP(4)-TEMP(1))
               END IF
	 
	         !THE 2-ND POINT IS UNDEFINED
	         IF(MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2)).EQ.1) THEN
	            MATRX_ELMNT_INTRP(I,J,1)=SNGL(TEMP(1)+TEMP(2))
	            MATRX_ELMNT_INTRP(I,J,2)=0.0
	            MATRX_ELMNT_INTRP(I,J,3)=SNGL(TEMP(3)-TEMP(2))
	            MATRX_ELMNT_INTRP(I,J,4)=SNGL(TEMP(4)+TEMP(2))
	         END IF
	
	         !THE 3-RD POINT IS UNDEFINED
	         IF(MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3)).EQ.1) THEN
	            MATRX_ELMNT_INTRP(I,J,1)=SNGL(TEMP(1)+TEMP(3))
	            MATRX_ELMNT_INTRP(I,J,2)=SNGL(TEMP(2)-TEMP(3))
	            MATRX_ELMNT_INTRP(I,J,3)=0.0
	            MATRX_ELMNT_INTRP(I,J,4)=SNGL(TEMP(4)+TEMP(3))
			 END IF

	         !THE 4-TH POINT IS UNDEFINED	       
		     IF(MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4)).EQ.1) THEN
	            MATRX_ELMNT_INTRP(I,J,1)=SNGL(TEMP(1)-TEMP(4))
	            MATRX_ELMNT_INTRP(I,J,2)=SNGL(TEMP(2)+TEMP(4))
	            MATRX_ELMNT_INTRP(I,J,3)=SNGL(TEMP(3)+TEMP(4))
	            MATRX_ELMNT_INTRP(I,J,4)=0.0
		     END IF 
C----------END OF PROCEDURE IF 3 POINTS ARE DEFINED---------
		 
		   ELSE
C---------- PROCEDURE IF 2 POINTS ARE DEFINED---------
	          IF((MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1))+
     &              MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2))+
     &              MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3))+
     &              MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4))).EQ.2) THEN
	
	         !THE 1-ST AND THE 2-ND POINTS ARE UNDEFINED		   
		     IF((MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1)).EQ.1).AND.
     &            (MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2)).EQ.1)) THEN
	             MATRX_ELMNT_INTRP(I,J,1)=0.0
	             MATRX_ELMNT_INTRP(I,J,2)=0.0
	             MATRX_ELMNT_INTRP(I,J,3)=SNGL(TEMP(1)+TEMP(3))
	             MATRX_ELMNT_INTRP(I,J,4)=SNGL(TEMP(2)+TEMP(4))
	         END IF

	         !THE 1-ST AND THE 3-RD POINTS ARE UNDEFINED
		     IF((MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1)).EQ.1).AND.
     &            (MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3)).EQ.1)) THEN
	             MATRX_ELMNT_INTRP(I,J,1)=0.0
	             MATRX_ELMNT_INTRP(I,J,2)=SNGL(TEMP(1)+TEMP(2))
	             MATRX_ELMNT_INTRP(I,J,3)=0.0
	             MATRX_ELMNT_INTRP(I,J,4)=SNGL(TEMP(3)+TEMP(4))
	         END IF

	         !THE 3-RD AND THE 4-TH POINTS ARE UNDEFINED		   
		     IF((MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3)).EQ.1).AND.
     &            (MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4)).EQ.1)) THEN
	             MATRX_ELMNT_INTRP(I,J,1)=SNGL(TEMP(1)+TEMP(3))
	             MATRX_ELMNT_INTRP(I,J,2)=SNGL(TEMP(2)+TEMP(4))
	             MATRX_ELMNT_INTRP(I,J,3)=0.0
	             MATRX_ELMNT_INTRP(I,J,4)=0.0
	         END IF

	         !THE 4-TH AND THE 2-ND POINTS ARE UNDEFINED
		     IF((MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4)).EQ.1).AND.
     &            (MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2)).EQ.1)) THEN
	             MATRX_ELMNT_INTRP(I,J,1)=SNGL(TEMP(1)+TEMP(2))
	             MATRX_ELMNT_INTRP(I,J,2)=0.0
	             MATRX_ELMNT_INTRP(I,J,3)=SNGL(TEMP(3)+TEMP(4))
	             MATRX_ELMNT_INTRP(I,J,4)=0.0
	         END IF

	         !THE 1-ST AND THE 4-TH POINTS ARE UNDEFINED
		     IF((MASKIN(I_INPUT(I,J,1),J_INPUT(I,J,1)).EQ.1).AND.
     &            (MASKIN(I_INPUT(I,J,4),J_INPUT(I,J,4)).EQ.1)) THEN
	             MATRX_ELMNT_INTRP(I,J,1)=0.0
	             MATRX_ELMNT_INTRP(I,J,2)=SNGL(TEMP(1)+TEMP(2))
	             MATRX_ELMNT_INTRP(I,J,3)=SNGL(TEMP(3)+TEMP(4))
	             MATRX_ELMNT_INTRP(I,J,4)=0.0
	         END IF

	         !THE 2-ND AND THE 3-RD POINTS ARE UNDEFINED
		     IF((MASKIN(I_INPUT(I,J,3),J_INPUT(I,J,3)).EQ.1).AND.
     &            (MASKIN(I_INPUT(I,J,2),J_INPUT(I,J,2)).EQ.1)) THEN
                   MATRX_ELMNT_INTRP(I,J,1)=SNGL(TEMP(1)+TEMP(2))
	             MATRX_ELMNT_INTRP(I,J,2)=0.0
	             MATRX_ELMNT_INTRP(I,J,3)=0.0
	             MATRX_ELMNT_INTRP(I,J,4)=SNGL(TEMP(3)+TEMP(4))
	         END IF

C----------END OF PROCEDURE IF 2 POINTS ARE DEFINED---------	         
			 
			  ELSE
C---------- PROCEDURE IF 1 POINTS IS DEFINED---------	
		 				
	          DO K=1,4
		       IF(MASKIN(I_INPUT(I,J,K),J_INPUT(I,J,K)).EQ.0) THEN
	             MATRX_ELMNT_INTRP(I,J,K)=1.0
	           ELSE
	             MATRX_ELMNT_INTRP(I,J,K)=0.0
	           END IF
	          END DO

C----------END OF PROCEDURE IF 2 POINTS ARE DEFINED---------				 
			  END IF
             END IF
	    END IF

	  ELSE
         DO K=1,4
          MATRX_ELMNT_INTRP(I,J,K)=0.0
          I_INPUT(I,J,K)=0
          J_INPUT(I,J,K)=0
	   END DO
	  END IF

      MATRX_ELMNT_INTRP(i,j,:)=min(MATRX_ELMNT_INTRP(i,j,:),1.0)
      MATRX_ELMNT_INTRP(i,j,:)=max(MATRX_ELMNT_INTRP(i,j,:),0.0)  

C--------REMORMING OF MATRIX ELEMENTS-------------------------------
500       SUM_MATR_ELMNT=MATRX_ELMNT_INTRP(I,J,1)
     &                  +MATRX_ELMNT_INTRP(I,J,2)
     &                  +MATRX_ELMNT_INTRP(I,J,3)
     &                  +MATRX_ELMNT_INTRP(I,J,4)

	  MATRX_ELMNT_INTRP(I,J,:)=
     &  MATRX_ELMNT_INTRP(I,J,:)/SUM_MATR_ELMNT

	 SUM_ROTVEC_COEFF=SQRT(ROTVEC_COEFF(I,J,1)*ROTVEC_COEFF(I,J,4)-
     &                       ROTVEC_COEFF(I,J,2)*ROTVEC_COEFF(I,J,3))

	 IF(SUM_ROTVEC_COEFF.NE.0.0)
     &        ROTVEC_COEFF(I,J,:)=ROTVEC_COEFF(I,J,:)/SUM_ROTVEC_COEFF
                 
501      CONTINUE
     	  	  
	 END DO
	END DO

	DEALLOCATE (DFM1,DF,TEMP,YINP,XINP)

      RETURN

1941  WRITE(*,*) 'ENTIRE GRID UNDEFINED!!!'
      STOP
	
	END
C==========================================================================
C SCALAR FIELD INTERPOLATION FROM ATM TO OCEAN
      SUBROUTINE INTERPOLROT_SCAL(
     &     NXIN,       !NUMBER OF X-GRID POINTS(INPUT)
     &     NYIN,       !NUMBER OF Y-GRID POINTS(INPUT)
     &    NXOUT,       !NUMBER OF X-GRID POINTS(OUTPUT)
     &    NYOUT,       !NUMBER OF Y-GRID POINTS(OUTPUT)
     &   FUNCIN,       !INPUT DATA ARRAY
     &  FUNCOUT,       !OUTPUT DATA ARRAY
     &  I_INPUT,       !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  J_INPUT,       !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  COEFFICIENT,   !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     &  MASKOUT,       !SEA-LAND MASK FOR OUTPUT DATA
     &  UNDEFOUT,
     &     MMM_OUT,    !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     MM_OUT,     ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     NNN_OUT,    !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &     NN_OUT)     ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)


	IMPLICIT NONE

	INTEGER NXIN,NYIN,NXOUT,NYOUT
	INTEGER MMM_OUT, MM_OUT, NNN_OUT, NN_OUT

	REAL(4) FUNCIN(NXIN,NYIN), FUNCOUT(NXOUT,NYOUT)

	REAL(4) COEFFICIENT(NXOUT,NYOUT,4),UNDEFOUT

	INTEGER I_INPUT(NXOUT,NYOUT,4), !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &        J_INPUT(NXOUT,NYOUT,4)  !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
      REAL(4) MASKOUT(NXOUT,NYOUT)

	INTEGER I,J

!$OMP PARALLEL DO PRIVATE(I,J)
	 DO J=NNN_OUT,NN_OUT
	  DO I=MMM_OUT,MM_OUT
         IF (MASKOUT(I,J).LE.0.5) THEN
          FUNCOUT(I,J)=UNDEFOUT
	   ELSE

	    FUNCOUT(I,J)=
     &    COEFFICIENT(I,J,1)*FUNCIN(I_INPUT(I,J,1),J_INPUT(I,J,1))+
     &    COEFFICIENT(I,J,2)*FUNCIN(I_INPUT(I,J,2),J_INPUT(I,J,2))+
     &    COEFFICIENT(I,J,3)*FUNCIN(I_INPUT(I,J,3),J_INPUT(I,J,3))+
     &    COEFFICIENT(I,J,4)*FUNCIN(I_INPUT(I,J,4),J_INPUT(I,J,4))
         END IF
	  END DO
	 END DO
!$OMP END PARALLEL DO
      RETURN
	END
C===================================================================
C VECTOR FIELD INTERPOLATION FROM ATM TO OCEAN
      SUBROUTINE INTERPOLROT_VEC(
     &     NXIN,       !NUMBER OF X-GRID POINTS(INPUT)
     &     NYIN,       !NUMBER OF Y-GRID POINTS(INPUT)
     &    NXOUT,       !NUMBER OF X-GRID POINTS(OUTPUT)
     &    NYOUT,       !NUMBER OF Y-GRID POINTS(OUTPUT)
     &   FUNCIN_Z,       !INPUT ZONAL DATA ARRAY
     &   FUNCIN_M,       !INPUT MERIDIONAL DATA ARRAY
     &  FUNCOUT_Z,       !OUTPUT ZONAL DATA ARRAY
     &  FUNCOUT_M,       !OUTPUT MERIDIONAL DATA ARRAY
     &  I_INPUT,       !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  J_INPUT,       !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &  COEFFICIENT,   !NONZERO MATRIX ELEMENTS OF INTERPOLATION
     &  ROTVEC_COEFF,  !ANGLES BETWEEN PARALLELS
     &  MASKOUT,       !SEA-LAND MASK FOR OUTPUT DATA
     &  UNDEFOUT,     
     &     MMM_OUT,    !FIRST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     MM_OUT,     ! LAST SIGNIFICANT POINT IN X-DIRECTION (OUTPUT)
     &     NNN_OUT,    !FIRST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)
     &     NN_OUT)     ! LAST SIGNIFICANT POINT IN Y-DIRECTION (OUTPUT)


	IMPLICIT NONE

	INTEGER NXIN,NYIN,NXOUT,NYOUT
	INTEGER MMM_OUT, MM_OUT, NNN_OUT, NN_OUT

	REAL(4) FUNCIN_Z(NXIN,NYIN),  FUNCIN_M(NXIN,NYIN),
     &       FUNCOUT_Z(NXOUT,NYOUT),FUNCOUT_M(NXOUT,NYOUT),
     &       FUNC_ZON_UNROT,FUNC_MER_UNROT

	REAL(4) COEFFICIENT(NXOUT,NYOUT,4),
     &       ROTVEC_COEFF(NXOUT,NYOUT,4), UNDEFOUT

	INTEGER I_INPUT(NXOUT,NYOUT,4), !X-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
     &        J_INPUT(NXOUT,NYOUT,4)  !Y-GRID NUMBERS OF INPUT GRID FOR OUTPUT GRID
      REAL(4) MASKOUT(NXOUT,NYOUT)

	INTEGER I,J

!$OMP PARALLEL DO PRIVATE(I,J,FUNC_ZON_UNROT,FUNC_MER_UNROT)
	 DO J=NNN_OUT,NN_OUT
	  DO I=MMM_OUT,MM_OUT
         IF (MASKOUT(I,J).LE.0.5) THEN
          FUNCOUT_Z(I,J)=UNDEFOUT
	    FUNCOUT_M(I,J)=UNDEFOUT
	   ELSE
          FUNC_ZON_UNROT=
     &    COEFFICIENT(I,J,1)*FUNCIN_Z(I_INPUT(I,J,1),J_INPUT(I,J,1))+
     &    COEFFICIENT(I,J,2)*FUNCIN_Z(I_INPUT(I,J,2),J_INPUT(I,J,2))+
     &    COEFFICIENT(I,J,3)*FUNCIN_Z(I_INPUT(I,J,3),J_INPUT(I,J,3))+
     &    COEFFICIENT(I,J,4)*FUNCIN_Z(I_INPUT(I,J,4),J_INPUT(I,J,4))
	    
	    FUNC_MER_UNROT=
     &    COEFFICIENT(I,J,1)*FUNCIN_M(I_INPUT(I,J,1),J_INPUT(I,J,1))+
     &    COEFFICIENT(I,J,2)*FUNCIN_M(I_INPUT(I,J,2),J_INPUT(I,J,2))+
     &    COEFFICIENT(I,J,3)*FUNCIN_M(I_INPUT(I,J,3),J_INPUT(I,J,3))+
     &    COEFFICIENT(I,J,4)*FUNCIN_M(I_INPUT(I,J,4),J_INPUT(I,J,4))

      	FUNCOUT_Z(I,J)=ROTVEC_COEFF(I,J,1)*FUNC_ZON_UNROT+
     &                   ROTVEC_COEFF(I,J,2)*FUNC_MER_UNROT

      	FUNCOUT_M(I,J)=ROTVEC_COEFF(I,J,3)*FUNC_ZON_UNROT+
     &                   ROTVEC_COEFF(I,J,4)*FUNC_MER_UNROT

         END IF
	  END DO
	 END DO
!$OMP END PARALLEL DO
      RETURN
	END
